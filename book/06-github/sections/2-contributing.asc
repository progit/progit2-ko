//////////////////////////
=== Contributing to a Project
//////////////////////////
=== 프로젝트에 기여하기

//////////////////////////
Now that our account is setup, let's walk through some details that could be useful in helping you contribute to an existing project.
//////////////////////////
계정은 이제 만들었으니 프로젝트에 참여하는 방법을 살펴볼 차례가 됐다.

//////////////////////////
==== Forking Projects
//////////////////////////
==== 프로젝트 Fork 하기

(((forking)))
//////////////////////////
If you want to contribute to an existing project to which you don’t have push access, you can ``fork'' the project.
What this means is that GitHub will make a copy of the project that is entirely yours; it lives in your user's namespace, and you can push to it.
//////////////////////////
참여하고 싶은 프로젝트가 생기면 아마 그 프로젝트에 Push 할 권한은 없을 테니까 ``Fork''해야 한다.
``Fork''하면 GitHub이 프로젝트를 통째로 복사해서 해준다. 그 복사본은 사용자 네임스페이스에 있고 Push 할 수도 있다.

[NOTE]
//////////////////////////
====
Historically, the term ``fork'' has been somewhat negative in context, meaning that someone took an open source project in a different direction, sometimes creating a competing project and splitting the contributors.
In GitHub, a ``fork'' is simply the same project in your own namespace, allowing you to make changes to a project publicly as a way to contribute in a more open manner.
====
//////////////////////////
====
과거에는 ``Fork''가 좋은 의미로 쓰이지 않았다. 오픈 소스 프로젝트를 ``Fork''한다는 것은 복사해서 조금은 다른 프로젝트를 만드는 것을 의미했고 때때로 원래 프로젝트와 경쟁하거나 기여자를 나누는 결과를 가져오기도 했다.
GitHub에서 ``Fork''는 단순히 자신의 네임스페이스로 복사하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다.
====

//////////////////////////
This way, projects don’t have to worry about adding users as collaborators to give them push access.
People can fork a project, push to it, and contribute their changes back to the original repository by creating what's called a Pull Request, which we'll cover next.
This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the change until the owner is happy with it, at which point the owner can merge it in.
//////////////////////////
이 방식에서는 사람들을 프로젝트에 추가하고 Push 권한을 줘야 할 필요가 없다.
사람들은 프로젝트를 ``Fork''해서 Push 한다. 그리고 Push 한 변경 내용을 원래 저장소로 보내 기여한다. 이것을 Pull Request라고 부르는데 나중에 다시 설명한다.
토론 스레드를 만들고 거기서 코드 리뷰를 하면서 토론하는 스레드를 만들어 토론을 시작한다. 프로젝트 소유자 마음에 들 때까지 소유자와 기여자는 함께 토론한다. 마음에 들게 되면 Merge 한다.

//////////////////////////
To fork a project, visit the project page and click the ``Fork'' button at the top-right of the page.
//////////////////////////
프로젝트는 쉽게 Fork 할 수 있다. 프로젝트 페이지를 방문해서 오른쪽 꼭대기에 있는 ``Fork'' 버튼을 클릭한다.

//////////////////////////
.The ``Fork'' button.
image::images/forkbutton.png[The ``Fork'' button.]
//////////////////////////
.``Fork'' 버튼.
image::images/forkbutton.png[``Fork'' 버튼.]

//////////////////////////
After a few seconds, you'll be taken to your new project page, with your own writeable copy of the code.
//////////////////////////
몇 초안에 복사된 프로젝트 페이지로 이동한다. 이 새 프로젝트의 소유자는 Fork 한 사람 자신이기 때문에 쓰기 권한이 있다.

[[_github_flow]]
//////////////////////////
==== The GitHub Flow
//////////////////////////
==== GitHub 플로우

(((GitHub, Flow)))
//////////////////////////
GitHub is designed around a particular collaboration workflow, centered on Pull Requests.
This flow works whether you're collaborating with a tightly-knit team in a single shared repository, or a globally-distributed company or network of strangers contributing to an project through dozens of forks.
It is centered on the <<_topic_branch>> workflow covered in <<_git_branching>>.
//////////////////////////
GitHub은 Pull Request가 중심인 협업 Workflow를 위주로 설계됐다.
이 Workflow는 Fork 해서 프로젝트에 기여하는 것인데 단일 저장소만 사용하는 작은 팀이나 전 세계에서 흩어져서 일하는 회사, 혹은 한 번도 본 적 없는 사람들 사이에서도 유용하다.
<<_git_branching>> 에서 설명했던 <<_topic_branch>> 중심으로 일하는 방식이다.

//////////////////////////
Here's how it generally works:

1. Create a topic branch from `master`.
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.
//////////////////////////
보통은 아래와 같이 일한다.

1. `master`에서 토픽 브랜치를 만든다.
2. 뭔가 수정해서 커밋한다.
3. 자신의 GitHub 프로젝트에 브랜치를 Push 한다.
4. GitHub에 Pull Request를 연다.
5. 토론하면서 그에 따라 계속 커밋한다.
6. 프로젝트 소유자는 Pull Request를 Merge 하고 닫는다.

//////////////////////////
This is basically the Integration Manager workflow covered in <<_integration_manager>>, but instead of using email to communicate and review changes, teams use GitHub's web based tools.
//////////////////////////
이 방식은 기본적으로 <<_integration_manager>>에서 설명하는 Integration-Manager Workflow와 같다. 토론이나 리뷰를 이메일이 아니라 GitHub에서 제공하는 웹 기반 도구를 사용하는 것뿐이다.

//////////////////////////
Let's walk through an example of proposing a change to an open source project hosted on GitHub using this flow.
//////////////////////////
GitHub에 있는 오픈소스 프로젝트에 이 Workflow를 이용해서 뭔가 기여하는 예제를 살펴보자.

//////////////////////////
===== Creating a Pull Request
//////////////////////////
===== Pull Request 만들기

//////////////////////////
Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program file on GitHub at https://github.com/schacon/blink[].
//////////////////////////
Tony는 자신의 Arduino 장치에서 실행해볼 만한 코드를 찾고 있었고 GitHub에 있는 https://github.com/schacon/blink[]에서 매우 흡족한 프로그램을 찾았다.

//////////////////////////
.The project we want to contribute to.
image::images/blink-01-start.png[The project we want to contribute to.]
//////////////////////////
.기여하고자 하는 프로젝트.
image::images/blink-01-start.png[기여하고자 하는 프로젝트.]

//////////////////////////
The only problem is that the blinking rate is too fast, we think it's much nicer to wait 3 seconds instead of 1 in between each state change.
So let's improve the program and submit it back to the project as a proposed change.
//////////////////////////
다 좋은데 너무 빠르게 깜빡이는 게 마음에 안 들었다. 매초 깜빡이는 것보다 3초에 한 번 깜빡이는 게 더 좋을 것 같았다.
그래서 프로그램을 수정하고 원 프로젝트에 다시 보내기로 했다.

//////////////////////////
First, we click the 'Fork' button as mentioned earlier to get our own copy of the project.
Our user name here is ``tonychacon'' so our copy of this project is at `https://github.com/tonychacon/blink` and that's where we can edit it.
We will clone it locally, create a topic branch, make the code change and finally push that change back up to GitHub.
//////////////////////////
앞서 설명했던 것처럼 'Fork' 버튼을 클릭해서 프로젝트를 복사한다.
사용자 이름이 ``tonychacon''이라면  `https://github.com/tonychacon/blink`에 프로젝트가 복사된다. 이 프로젝트는 본인 프로젝트이고 수정할 수 있다.
이 프로젝트를 로컬에 Clone 해서 토픽 브랜치를 만들고 코드를 수정하고 나서 GitHub에 다시 Push 한다.

[source,shell]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[master 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

//////////////////////////
<1> Clone our fork of the project locally
<2> Create a descriptive topic branch
<3> Make our change to the code
<4> Check that the change is good
<5> Commit our change to the topic branch
<6> Push our new topic branch back up to our GitHub fork
//////////////////////////
<1> Fork 한 개인 저장소를 로컬에 Clone 한다.
<2> 무슨 일인지 설명이 되는 이름의 토픽 브랜치를 만든다.
<3> 코드를 수정한다.
<4> 잘 고쳤는지 확인한다.
<5> 토픽 브랜치에 커밋한다.
<6> GitHub의 개인 저장소에 토픽 브랜치를 Push 한다.

//////////////////////////
Now if we go back to our fork on GitHub, we can see that GitHub noticed that we pushed a new topic branch up and present us with a big green button to check out our changes and open a Pull Request to the original project.
//////////////////////////
Fork 한 내 저장소에 가면 GitHub은 토픽 브랜치가 하나 Push 됐다는 것을 알려주고 원 저장소에 Pull Request를 보낼 수 있는 큰 녹색 버튼을 보여준다.

//////////////////////////
You can alternatively go to the ``Branches'' page at `https://github.com/<user>/<project>/branches` to locate your branch and open a new Pull Request from there.
//////////////////////////
아니면 저장소의 브랜치 페이지로(`https://github.com/<user>/<project>/branches`) 가서 해당 브랜치의 ``New pull request'' 버튼을 이용한다.

//////////////////////////
.Pull Request button
image::images/blink-02-pr.png[Pull Request button]
//////////////////////////
.Pull Request 버튼
image::images/blink-02-pr.png[Pull Request 버튼]

(((GitHub, pull requests)))
//////////////////////////
If we click that green button, we'll see a screen that asks us to give our Pull Request a title and description.
It is almost always worthwhile to put some effort into this, since a good description helps the owner of the original project determine what you were trying to do, whether your proposed changes are correct, and whether accepting the changes would improve the original project.

If we click that green button, we'll see a screen that asks us to create a title and description for the change we would like to request so the project owner has a good reason to consider it. It is generally a good idea to spend some effort making this description as useful as possible so the author knows why this is being suggested and why it would be a valuable change for them to accept.
//////////////////////////
녹색 버튼을 클릭하면 Pull Request의 제목과 설명을 입력하는 화면이 보인다.
항샹 프로젝트 소유자가 판단을 내릴 수 있을 정도로 공을 들여 작성해야 한다. 왜 수정했는지 얼마나 가치 있는지 설명해서 관리자를 설득해야 한다.

//////////////////////////
We also see a list of the commits in our topic branch that are ``ahead'' of the `master` branch (in this case, just the one) and a unified diff of all the changes that will be made should this branch get merged by the project owner.
//////////////////////////
그리고 ``ahead'' 토픽 브랜치가 `master` 브랜치에서 달라진 커밋도 보여주고 수정된 내용을 ``unified diff'' 형식으로 보여준다. 이 수정 내용이 프로젝트 관리자가 Merge 할 내용이다.

//////////////////////////
.Pull Request creation page
image::images/blink-03-pull-request-open.png[Pull Request creation]
//////////////////////////
.Pull Request를 생성하는 페이지
image::images/blink-03-pull-request-open.png[Pull Request 생성]

//////////////////////////
When you hit the 'Create pull request' button on this screen, the owner of the project you forked will get a notification that someone is suggesting a change and will link to a page that has all of this information on it.
//////////////////////////
화면에 있는 'Create pull request' 버튼을 클릭하면 프로젝트 원소유자는 누군가 코드를 보냈다는 알림을 받는다. 그 알림에는 해당 Pull Request에 대한 모든 것을 보여주는 페이지의 링크가 들어 있다.

[NOTE]
//////////////////////////
====
Though Pull Requests are used commonly for public projects like this when the contributor has a complete change ready to be made, it's also often used in internal projects _at the beginning_ of the development cycle. Since you can keep pushing to the topic branch even *after* the Pull Request is opened, it's often opened early and used as a way to iterate on work as a team within a context, rather than opened at the very end of the process.
====
//////////////////////////
====
Pull Request는 보통 공개 프로젝트에서 사용한다. 기여자는 수정하고 나서 원 저장소에 Pull Request를 연다. 개발 초창기에는 프로젝트 내부에서도 많이 사용한다. 이미 Pull Request를 열어 놓은 토픽 브랜치라고 할지라도 계속 Push 할 수 있다. 마지막이 아니라 처음부터 Pull Request를 열면 어떤 주제를 가지고 팀 동료와 함께 토론할 수 있어서 좋다.
====

//////////////////////////
===== Iterating on a Pull Request
//////////////////////////
===== Pull Request 놓고 감 놓고 배 놓기

//////////////////////////
At this point, the project owner can look at the suggested change and merge it, reject it or comment on it. Let's say that he likes the idea, but would prefer a slightly longer time for the light to be off than on.
//////////////////////////
Pull Request가 오면 프로젝트 소유자는 변경 점이 무엇인지 확인한 후, Merge 혹은 거절하거나 코멘트를 달 수 있다. 소유자가 아이디어 자체를 마음에 들어 한다면 빛을 보기까지 좀 더 공을 들여야 한다.

//////////////////////////
Where this conversation may take place over email in the workflows presented in <<_distributed_git>>, on GitHub this happens online. The project owner can review the unified diff and leave a comment by clicking on any of the lines.
//////////////////////////
이런 소통을 이메일로 하는 Workflow는 <<_distributed_git>>에 설명했었다. GitHub에서는 온라인에서 한다. 프로젝트 소유자는 'unified diff' 형식의 변경사항을 검토하고 즉각 해당 라인에 코멘트를 달 수 있다.

//////////////////////////
.Comment on a specific line of code in a Pull Request
image::images/blink-04-pr-comment.png[PR line comment]
//////////////////////////
.Pull Request의 코드에 코멘트 달기
image::images/blink-04-pr-comment.png[PR 라인 코멘트]

//////////////////////////
Once the maintainer makes this comment, the person who opened the Pull Request (and indeed, anyone else watching the repository) will get a notification. We'll go over customizing this later, but if he had email notifications turned on, Tony would get an email like this:
//////////////////////////
관리자가 코멘트를 달면 Pull Request를 만든 사람에게 알림이 간다. 실제로는 저장소를 'Watch'하는 사람 모두에게 알림이 간다. 알림 정책은 설정할 수 있지만, 다음에 검토한다. 알림을 받는 Tony가 이메일 알림을 켜놨다면 이메일 알림도 받는다.

[[_email_notification]]
//////////////////////////
.Comments sent as email notifications
image::images/blink-04-email.png[Email notification]
//////////////////////////
.코멘트가 이메일 알림으로 온다.
image::images/blink-04-email.png[이메일 알림]

//////////////////////////
Anyone can also leave general comments on the Pull Request. In <<_pr_discussion>> we can see an example of the project owner both commenting on a line of code and then leaving a general comment in the discussion section. You can see that the code comments are brought into the conversation as well.
//////////////////////////
누구나 Pull Request에 코멘트를 달 수 있다. <<_pr_discussion>>를 보면 프로젝트 소유자가 코드에 코멘트를 달거나 Pull Request 자체에 코멘트를 달면서 토론하는 것을 보여 준다. 코드 코멘트도 맥락을 이루어 커뮤니케이션 할 수 있다.

[[_pr_discussion]]
//////////////////////////
.Pull Request discusson page
image::images/blink-05-general-comment.png[PR discussion page]
//////////////////////////
.Pull Request 토론 페이지
image::images/blink-05-general-comment.png[PR 토론 페이지]

//////////////////////////
Now the contributor can see what they need to do in order to get their change accepted.
Luckily this is very straightforward.
Where over email you may have to re-roll your series and resubmit it to the mailing list, with GitHub you simply commit to the topic branch again and push, which will automatically update the Pull Request.
In <<_pr_final>> you can also see that the old code comment has been collapsed in the updated Pull Request, since it was made on a line that has since been changed.
//////////////////////////
이 토론을 보고 기여자는 자신이 무엇을 해야 자신의 코드가 받아들여질지 알 수 있다.
다행히 매우 직관적이다.
만약 이 일을 이메일로 하고자 한다면 관련 커밋을 다시 말아서 메일링 리스트에 다시 보내야 한다. 하지만, GitHub에서는 해당 토픽 브랜치에 이어서 커밋하고 Push 하면 된다.
<<_pr_final>>에서 Push로 업데이트한 PR의 코드를 보면 예전 코드에 달렸던 코멘트는 나오지 않는다. 추가된 커밋으로 인해 코드가 수정되었기 때문이다.

//////////////////////////
Adding commits to an existing Pull Request doesn't trigger a notification, so once Tony has pushed his corrections he decides to leave a comment to inform the project owner that he made the requested change.
//////////////////////////
기존 PR에 이어서 Push를 하면 알림이 가지 않는다. 그래서 Tony는 자신이 작업한 내용을 코멘트로 남겼다. 그러면 프로젝트 소유자는 무슨 일이 있었는지 쉽게 알 수 있다.

[[_pr_final]]
//////////////////////////
.Pull Request final
image::images/blink-06-final.png[PR final]
//////////////////////////
.최종 Pull Request
image::images/blink-06-final.png[최종 PR]

//////////////////////////
An interesting thing to notice is that if you click on the ``Files Changed'' tab on this Pull Request, you'll get the ``unified'' diff -- that is, the total aggregate difference that would be introduced to your main branch if this topic branch was merged in. In `git diff` terms, it basically automatically shows you `git diff master...<branch>` for the branch this Pull Request is based on. See <<_what_is_introduced>> for more about this type of diff.
//////////////////////////
꼭 짚고 넘어가야 할 것이 있다. 이 Pull Request의 ``Files Changed'' 탭을 클릭하면 ``unified'' diff를 볼 수 있다. 이 Pull Request가 주 브랜치에 Merge 되면 어떻게 달라지는지 보여준다. `git diff` 명령을 빌어 표현하자면 `git diff master...<branch>`와 같은 명령이 실행되는 거고 `<branch>`는 Pull Request의 브랜치를 의미한다. <<_what_is_introduced>>에서 자세히 설명한다.

//////////////////////////
The other thing you'll notice is that GitHub checks to see if the Pull Request merges cleanly and provides a button to do the merge for you on the server. This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a ``non-fast-forward'' merge, meaning that even if the merge *could* be a fast-forward, it will still create a merge commit.
//////////////////////////
그 외 알아두면 좋은 것은 GitHub은 Pull Request가 Merge 될 수 있는지 검사해서 서버에서 Merge 할 수 있도록 Merge 버튼을 제공한다. 이 버튼은 저장소에 쓰기 권한이 있는 사람만 볼 수 있고 이 버튼으로 Merge 하면 Merge 커밋이 생긴다(Trivial Merge). ``fast-forward'' Merge가 가능할 때도 ``non-fast-forwrd''로 Merge 한다.

//////////////////////////
If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the `master` branch and push it to GitHub, the Pull Request will automatically be closed.
//////////////////////////
로컬에 Pull Request 브랜치를 당겨와서 Merge 해도 된다. `master` 브랜치에 Merge 해서 GitHub에 Push 하면 자동으로 해당 Pull Request가 닫힌다.

//////////////////////////
This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests are opened on them, a discussion ensues, possibly more work is done on the branch and eventually the request is either closed or merged.
//////////////////////////
이것은 대부분의 GitHub 프로젝트가 사용하는 기본 Workflow이다. 토픽 브랜치를 만들고 Pull Request를 연다. 거시서 토론을 계속 하고 그 브랜치에 커밋도 좀 하고 한다. 최종적으로 일하면 Merge 하고 닫는다.

[NOTE]
//////////////////////////
.Not Only Forks
====
It's important to note that you can also open a Pull Request between two branches in the same repository. If you're working on a feature with someone and you both have write access to the project, you can push a topic branch to the repository and open a Pull Request on it to the `master` branch of that same project to initiate the code review and discussion process. No forking neccesary.
====
//////////////////////////
.Fork는 옵션
====
한 저장소의 두 브랜치를 두고도 Pull Request를 열 수 있다. 한 저장소에 쓰기 권한이 있는 동료 둘이서 어떤 기능을 추가하려고 하고 있다면 토픽 브랜치를 만들고 Push 한다. 그리고 나서 같은 저장소의 `master` 브랜치에 대해 Pull Request를 만들어 코드 리뷰와 토론을 시작한다. Fork는 필수가 아니다.
====

//////////////////////////
==== Advanced Pull Requests
//////////////////////////
==== Pull Request 팁

//////////////////////////
Now that we've covered the basics of contributing to a project on GitHub, let's cover a few interesting tips and tricks about Pull Requests so you can be more effective in using them.
//////////////////////////

GitHub에서 프로젝트에 기여하는 방법 중 가장 기본적인 방법을 살펴봤다. Pull Request를 사용할 때 도움이 되는 유용한 팁을 몇 가지 살펴보자.

//////////////////////////
===== Pull Requests as Patches
//////////////////////////
===== Patch를 Pull Request로 보내기

//////////////////////////
It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions. Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.
//////////////////////////
보통 프로젝트에서는 Pull Request의 Patch가 완벽하고 큐처럼 꼭 순서대로 적용돼야 한다고 생각하지 않는다. 메일링 리스트를 사용하던 프로젝트에서는 Patch 순서가 의미가 있다고 생각한다. Github의 Pull Request는 어떤 주제를 두고 논의하는 자리다. 논의가 다 무르익으면 Merge 한다.

//////////////////////////
This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.
//////////////////////////
이 차이는 매우 중요하다. 일반적으로 처음부터 완벽한 코드를 보낼 수 없어서 메일링 리스트로 Patch를 보낼 일은 별로 없다. Pull Request는 초기부터 프로젝트 관리자와 소통할 수 있도록 해주기 때문에 혼자 답을 찾는 게 아니라 커뮤니티에서 함께 찾을 수 있다. 누군가 Pull Request를 열면 관리자와 커뮤니티는 어떻게 수정하는 게 좋을지 의견을 낸다. Patch를 처음부터 다시 전체를 작성하지 않아도 된다. 수정한 만큼만 해당 브랜치에 커밋하고 하던 일과 대화를 계속 해 나가면 된다.

//////////////////////////
For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.
//////////////////////////
<<_pr_final>>로 돌아가서 다시 보면 기여자가 커밋을 Rebase 하거나 Pull Request를 다시 열지 않았다는 것을 확인할 수 있다. 그냥 기존 브랜치에 좀 더 커밋하고 Push 했을 뿐이다. 나중에 시간이 지나서 이 Pull Request를 다시 읽으면 왜 이런 방향으로 결정했는지에 대한 맥락을 쉽게 알 수 있다. 웹 사이트에서 ``Merge'' 버튼을 누르면 Merge 커밋을 일부러 남기겠다는 뜻이 된다. 이 Merge 커밋에는 Pull Request 정보가 들어가기 때문에 필요하면 언제든지 Mac락을 확인할 수 있다.

//////////////////////////
===== Keeping up with Upstream
//////////////////////////
===== Pull Request를 최신으로 업데이트하기

//////////////////////////
If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.
//////////////////////////
Pull Request가 만든 지 오래됐거나 깨끗하게 Merge 되지 않으면 메인테이너가 쉽게 Merge 할 수 있게 수정한다. GitHub은 자동으로 Merge 할 수 있는 Pull Request인지 아닌지 Pull Request 페이지 하단에서 알려준다.

[[_pr_fail]]
//////////////////////////
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]
//////////////////////////
.깨끗하게 Merge 할 수 없는 Pull Request
image::images/pr-01-fail.png[PR Merge 실패]

//////////////////////////
If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.
//////////////////////////
<<_pr_fail>> 같은 메시지를 보면 해당 브랜치를 고쳐서 녹색으로 만든다. 메인테이너가 고치지 않아도 되도록 한다.

//////////////////////////
You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.
//////////////////////////
이 문제를 해결하는 방법은 두 가지가 있다. 대상 브랜치(보통은 `master` 브랜치)를 기준으로 Rebase 하는 방법이 있고 대상 브랜치를 Pull Request 브랜치에 Merge 하는 방법이 있다.

//////////////////////////
Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.
//////////////////////////
GitHub을 사용하는 개발자는 대부분 후자를 고른다. 앞서 살펴봤던 것과 같은 이유다. Rebase 하면 히스토리는 깨끗해지지만 *훨씬* 더 어렵고 에러 나기 쉽다.

//////////////////////////
If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.
//////////////////////////
Pull Request가 Merge 될 수 있도록 대상 브랜치를 Merge 하려면 먼저 원 저장소를 리모트로 추가한다. 그리고 나서 Fetch 하고 그 저장소의 대상 브랜치를 해당 토픽 브랜치에 Merge 한다. 문제를 해결하고 그 브랜치에 도로 Push 한다.

//////////////////////////
For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.
//////////////////////////
``tonychacon'' 예제에 이 Workflow를 적용해보자. 원저자가 뭔가 수정을 했는데 Pull Request와 충돌이 난다. 여기부터 살펴보자.

[source,shell]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

//////////////////////////
<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch into your topic branch
<4> Fix the conflict that occured
<5> Push back up to the same topic branch
//////////////////////////
<1> 원 저장소를 ``upstream''이라는 이름의 리모트로 추가한다
<2> 리모트에서 최신 데이터를 Fetch 한다
<3> 대상 브랜치를 토픽 브랜치에 Merge 한다
<4> 충돌을 해결한다
<5> 동일한 토픽 브랜치에 도로 Push 한다

//////////////////////////
Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.
//////////////////////////
이렇게 하면 Pull Request는 자동으로 업데이트되고 깨끗하게 Merge 할 수 있는지 재확인된다.

[[_pr_fail]]
//////////////////////////
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]
//////////////////////////
.Pull Request가 깨끗하게 Merge 할 수 있게 됐다.
image::images/pr-02-merge-fix.png[PR 고침]

//////////////////////////
One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.
//////////////////////////
연속성은 Git의 장기 중 하나다. 오랫동안 무엇인가 만들고 있다면 최신으로 유지하기 위해 대상 브랜치를 쉽게 Merge 해 올 수 있다. 다 마칠 때까지 하고 또 하고 할 수 있다. Merge 할 때 발생하는 충돌만 해결하면 되고 지속적으로 개발 프로세스를 관리할 수 있다.

//////////////////////////
If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.
//////////////////////////
브랜치를 꼭 깨끗하게 유지하고 싶어서 Rebase 해야 한다고 생각한다면 이미 열어 놓은 Pull Request에 대고 Push 하지 말아야 한다. 그럼 이 브랜치를 가져다 Merge 해 놓은 사람들은 <<_rebase_peril>>에 설명했듯이 충격에 빠질 것이다. 대신 브랜치를 새로 만들어 Push 한다. 그리고 Pull Request도 새로 여는데 원 Pull Request가 뭔지 알 수 있도록 참조를 달고 원래 것은 닫는다.

//////////////////////////
===== References
//////////////////////////
===== 참조

//////////////////////////
Your next question may be ``How to I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.
//////////////////////////
그럼 바로 "어떻게 Pull Request를 참조시키지?"라는 의문이 들겠지만, 방법은 매우 많다. GitHub에 쓰기 가능한 곳 어디에서나 참조를 달 수 있다.

//////////////////////////
Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.
//////////////////////////
먼저 Issue와 Pull Request를 서로 참조시키는 방법부터 살펴보자. 모든 Pull Request와 Issue에는 프로젝트 내에서 유일한 번호를 하나 할당한다. 예를 들어, #3인 Pull Request와 #3인 Issue는 동시에 있을 수 없다. `#<num>`과 같은 형태로 코멘트가나 설명에 Pull Request와 Issue를 참조시킬 수 있다. 이 방법은 단일 프로젝트 범위에서만 유효하다. Fork 저장소의 Issue나 Pull Request를 참조시키려고 한다면 `username#<num>`라고 쓰고 아예 다른 저장소면 `username/repo#<num>`라고 써야 한다.

//////////////////////////
Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.
//////////////////////////
설명을 위해 이미 브랜치를 Rebase 했고 Pull Request를 새로 만들었다고 하자. 그럼 예전 Pull Request가 뭔지 알 수 있도록 새것에서 예전 것을 참조하게 해보고 <<_pr_references>>같이 Fork 한 저장소의 이슈나 아예 다른 저장소의 이슈도 참조하게 해보자.

[[_pr_references]]
//////////////////////////
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]
//////////////////////////
.Pull Request의 상호 참조 편집.
image::images/mentions-01-syntax.png[PR 참조 편집]

//////////////////////////
When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.
//////////////////////////
이 Pull Request를 보내면 <<_pr_references_render>>처럼 보인다.

[[_pr_references_render]]
//////////////////////////
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]
//////////////////////////
.Pull Request의 상호 참조.
image::images/mentions-02-render.png[PR 참조]

//////////////////////////
Notice that the full GitHub URL we put in there was shortened to just the information needed.
//////////////////////////
GitHub URL을 전부 입력해도 딱 필요한 만큼으로 줄어든다.

//////////////////////////
Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superceded it. The link will look something like <<_pr_closed>>.
//////////////////////////
그리고 원래 있던 Pull Request를 닫으면 새 Pull Request에는 기존 Pull Request가 닫혔다고 언급된다. Github은 Pull Request 타임라인에 트랙백 이벤트를 자동으로 만든다. 그래서 이 Pull Request에 방문하는 사람은 예전 Pull Request가 닫혔는지 알 수 있고 그 링크가 있어서 바로 클릭해서 예전 것을 볼 수 있다. 이 링크는 <<_pr_closed>>처럼 생겼다.

[[_pr_closed]]
//////////////////////////
.Cross references rendered in a Pull Request.
image::images/mentions-03-closed.png[PR closed]
//////////////////////////
.닫은 Pull Request의 트랙백
image::images/mentions-03-closed.png[닫은 PR의 트랙백]

//////////////////////////
In addition to issue numbers, you can also reference a specific commit by SHA. You have to specify a full 40 character SHA, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.
//////////////////////////
이슈뿐만 아니라 커밋의 SHA도 참조할 수 있다. 40자 SHA를 적으면 GitHub은 자동으로 해당 커밋에 링크를 걸어 준다. Fork 저장소나 아예 다른 저장소의 커밋도 이슈와 동일한 방식으로 링크시킬 수 있다.

==== Markdown

//////////////////////////
Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.
//////////////////////////
다른 이슈를 링크하는 것은 GitHub 글쓰기의 첫걸음에 불과하다. ``GitHub Flavored Markdown''이라는 형식으로 이슈나 Pull Request의 설명, 코멘트, 코드 주석 등에서 글을 쓸 수 있다. Markdown 형식으로 글을 쓰면 그냥 텍스트로 쓴 글이지만 형식을 갖춰 미끈하고 아름답게 렌더링된다.

//////////////////////////
See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.
//////////////////////////
<<_example_markdown>>는 Markdown으로 쓴 글이 어떻게 렌더링되는지 보여준다.

[[_example_markdown]]
//////////////////////////
.An example of Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]
//////////////////////////
.Markdown 예제.
image::images/markdown-01-example.png[Markdown 예제]

===== GitHub Flavored Markdown

//////////////////////////
The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.
//////////////////////////
GitHub Flavored Markdown(이하 GFM)은 기본 Markdown을 확장했다. GFM은 Pull Request나 이슈 등의 글을 쓸 때 매우 유용하다.

//////////////////////////
====== Task Lists
//////////////////////////
====== 타스크 리스트

//////////////////////////
The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.
//////////////////////////
GFM이 확장한 것 기능 중 타스크 리스트가 있는데 Pull Request에서 사용하면 좋다. 간단히 말해서 타스크 리스트는 완료했다고 표시할 수 있는 체크박스의 목록이다. 이슈나 Pull Request에서 다 했다고 표기하고 싶을 때 사용한다.

//////////////////////////
You can create a task list like this:
//////////////////////////
타스크 리스트는 아래와 같이 사용한다.:

[source,text]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

//////////////////////////
If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_task_lists>>
//////////////////////////
이 타스크 리스트를 이슈나 Pull Request에 사용하면 <<_task_lists>>처럼 렌더링된다.

[[_task_lists]]
//////////////////////////
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]
//////////////////////////
.타스크 리스트.
image::images/markdown-02-tasks.png[타스크 리스트]

//////////////////////////
This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.
//////////////////////////
Pull Request를 Merge 하기 전에 꼭 처리해야 하는 일의 목록을 표현할 때 타스크 리스트를 사용한다. Markdown을 직접 고치지 않고 체크박스만 클릭해도 해당 타스크가 완료됐다고 업데이트되기 때문에 상당히 좋은 기능이다.

//////////////////////////
What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.
//////////////////////////
GitHub은 이슈나 Pull Requests에 있는 타스크 리스트를 집계해서 목록 화면에서 보여준다. 예를 들어, 타스크들이 정리된 Pull Request가 있으면 Pull Request 요약 페이지에서 얼마나 진행됐는지 볼 수 있다. 그래서 Pull Request를 타스크 여러 개로 쪼개 두면 그 브랜치가 얼마나 진행됐는지 알기 쉽다. <<_task_list_progress>>를 보자.

[[_task_list_progress]]
//////////////////////////
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]
//////////////////////////
.Pull Request 목록 화면에서 보여주는 타스크 현황.
image::images/markdown-03-task-summary.png[타스크 리스트의 예]

//////////////////////////
These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.
//////////////////////////
Pull Request부터 열어 두고 일을 하면 해당 기능이 얼마나 진행됐는지 쉽게 알 수 있다.

//////////////////////////
====== Code Snippets
//////////////////////////
====== 코드 스니펫

//////////////////////////
You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.
//////////////////////////
코멘트에 코드 스니펫도 넣을 수 있다. 실제로 구현해서 브랜치에 커밋하기 전에 뭔가 아이디어를 코드로 표현해 볼 때 좋다. 그 외에도 단순히 코드 예제를 보여주기 위해서 사용하거나 해당 Pull Request에서 구현한 것이 무엇인지 보여줄 때도 사용한다.

//////////////////////////
To add a snippet of code you have to ``fence'' it in backticks.
//////////////////////////
백틱으로 된 ``Fence'' 안에 코드 스니펫을 넣는다.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

//////////////////////////
If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.
//////////////////////////
코드 스니펫에 언어 이름을 쓰면 GitHub은 구문강조(Syntax Highlight)도 해준다. <<_md_code>>는 언어 이름을 넣어서 구문 강조된 결과다.

[[_md_code]]
//////////////////////////
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]
//////////////////////////
.구문강조로 미끈해진 코드.
image::images/markdown-04-fenced-code.png[미끈한 코드]

//////////////////////////
====== Quoting
//////////////////////////
====== 인용

//////////////////////////
If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.
//////////////////////////
아주 긴 글에서 딱 한 부분만 집어서 논의하고 싶을 때 `>` 문자로 해당 부분을 인용하고 그 밑에 코멘트를 단다. 이 방법은 매우 흔히 사용하는 방법이라, 상당히 유용하고, 단축키도 지원한다. 인용하고 싶은 텍스트를 선택하고 `r` 키를 누르면 바로 코멘트 상자에 해당 텍스트가 인용된다.

//////////////////////////
The quotes look something like this:
//////////////////////////
아래와 같이 인용한다.

[source,text]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

//////////////////////////
Once rendered, the comment will look like <<_md_quote>>.
//////////////////////////
이 텍스트는 <<_md_quote>>처럼 렌더링된다.

[[_md_quote]]
//////////////////////////
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]
//////////////////////////
.인용 예제.
image::images/markdown-05-quote.png[인용 예제]

====== Emoji

//////////////////////////
Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.
//////////////////////////
마지막으로 소개하는 것은 글에 Emoji를 넣을 수 있다는 것이다. Emoji는 GitHub 이슈나 Pull Request에서 정말 많이 사용된다. GitHub은 Emoji를 쉽게 사용할 수 있도록 돕는다. 코멘트를 쓸 때 `:` 문자로 Emoji 입력을 시작하면 선택해서 자동완성할 수 있도록 Emoji 목록을 보여준다.

[[_md_emoji_auto]]
//////////////////////////
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]
//////////////////////////
.Emoji 자동완성.
image::images/markdown-06-emoji-complete.png[Emoji 자동완성]

//////////////////////////
Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:
//////////////////////////
Emoji는 `:<name>:` 형식으로 생겼다. 아래 예제를 보자.

[source,text]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

//////////////////////////
When rendered, it would look something like <<_md_emoji>>.
//////////////////////////
렌더링되면 <<_md_emoji>>처럼 보인다.

[[_md_emoji]]
//////////////////////////
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]
//////////////////////////
.Emoji를 많이 쓴 글.
image::images/markdown-07-emoji.png[Emoji]

//////////////////////////
Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.
//////////////////////////
Emoji는 정보 전달하는 데도 좋지만 얼마나 재밌고 기쁜지 같은 표현도 가능하다.

[NOTE]
//////////////////////////
====
There are actually quite a number of web services that make use of emoji charaters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====
//////////////////////////
====
Emoji 문자를 사용하는 웹 서비스가 정말 많다. 어떤 Emoji 문자가 있는지 쉽게 찾아볼 수 있는 치트시트가 있어서 두고두고 참고할 수 있다.

http://www.emoji-cheat-sheet.com
====

//////////////////////////
====== Images
//////////////////////////
====== 이미지

//////////////////////////
This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.
//////////////////////////
GitHub이 제공하는 글에 이미지를 포함시키는 기능은 기술적으로 GFM이 아니지만 엄청 유용하다. Markdown 형식으로 이미지를 첨부하고 싶을 때 일반적인 방법으로는 이미지를 올리고 그 URL을 찾아서 일일이 입력해야 하는데 번거롭다. GitHub에서는 그냥 이미지를 바로 Drag-and-Drop으로 붙여 넣을 수 있다.

[[_md_drag]]
//////////////////////////
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]
//////////////////////////
.끌어다 놓으면 이미지가 자동으로 붙는다.
image::images/markdown-08-drag-drop.png[Drag and drop images]

//////////////////////////
If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
//////////////////////////
<<_pr_references>>로 돌아가서 보면 Text Area 위에 ``Parsed As Markdown''이라는 표시를 볼 수 있다. 그 링크를 클릭하면 GitHub에서 Markdown을 어떻게 사용하는지 알려주는 치트시트를 보여준다.
