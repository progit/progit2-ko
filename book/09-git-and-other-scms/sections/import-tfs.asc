[[_git_tfs]]
==== TFS

(((TFS)))(((Importing, from TFS)))
////////////
If your team is convering their source control from TFVC to Git, you'll want the highest-fidelity conversion you can get.
This means that, while we covered both git-tfs and git-tf for the interop section, we'll only be covering git-tfs for this part, because git-tfs supports branches, and this is prohibitively difficult using git-tf.
////////////
팀에서 사용하던 TFVC를 Git으로 옮겨가기로 했다면 가능한 한 많은 데이터를 옮기고자 할 것이다.
우리가 앞에서 git-tfs와 git-tf를 둘 다 다뤘지만 여기서는 git-tfs만 사용한다. git-tfs는 브랜치를 지원하지만, git-tf로는 힘들기 때문이다.


[NOTE]
====
////////////
This is a one-way conversion.
The resulting Git repository won't be able to connect with the original TFVC project.
////////////
여기서 다루는 변환은 단방향 변환이다.
변환 후에 생성되는 Git 저장소는 TFVC의 원 저장소와는 아무런 연결고리가 없다.
====

////////////
The first thing to do is map usernames.
TFVC is fairly liberal with what goes into the author field for changesets, but Git wants a human-readable name and email address.
You can get this information from the `tf` command-line client, like so:
////////////
처음으로 해야 하는 일은 사용자 이름을 대응시키는 것이다.
TFVC는 변경 집합의 작성자 필드를 바꾸는 것이 상당히 자유롭지만 Git에는 사람이 읽을 수 있는 이름과 E-mail 주소를 입력해야 한다.
그 정보들은 커맨드라인 클라이언트인 `tf`로 가져올 수 있다.

[source,powershell]
----
PS> tf history $/myproject -recursive | cut -b 11-20 | tail -n+3 | uniq | sort > AUTHORS
----

////////////
This grabs all of the changesets in the history of the project.
The `cut` command ignores everything except characters 11-20 from each line (you'll have to experiment with the length of the fields to get these numbers right).
The `tail` command skips the first two lines, which are field headers and ASCII-art underlines.
The result of all of this is piped to `uniq` to eliminate duplicates, and saved to a file named `AUTHORS`.
The next step is manual; in order for git-tfs to make effective use of this file, each line must be in this format:
////////////
이 명령어는 먼저 프로젝트 히스토리의 모든 변경 집합을 가져온다.
`cut` 명령어는 각 라인에서 11-20의 문자열만 취한다. (몇 번 실험해서 해당 필드를 자를 수 있는 적당한 숫자를 알아내야 한다.)
`tail`명령어로는 위에서 두 줄을 건너뛴다. 위 두 줄은 필드 헤더와 밑줄이다.
그 결과물을 `uniq`에 파이프로 집어넣어 중복을 지운다. 그리고는 `AUTHORS` 파일에 저장한다.
그다음은 수동으로 한다. git-tfs이 이 파일을 잘 읽어내려면 각 파일은 다음과 같은 포맷이어야 한다.

[source,text]
----
DOMAIN\username = User Name <email@address.com>
----

////////////
The portion on the left is the ``User'' field from TFVC, and the portion on the right side of the equals sign is the user name that will be used for Git commits.
////////////
등호 부호를 기준으로 왼쪽은 TFVC의 ``User'' 필드고 오른쪽은 Git 커밋에 사용할 개발자 정보다.

////////////
Once you have this file, the next thing to do is make a full clone of the TFVC project you're interested in:
////////////
이 파일을 만들었으면 다음엔 원하는 TFVC 프로젝트를 완전히 Clone 한다.

[source,powershell]
----
PS> git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git
----

////////////
Next you'll want to clean the `git-tfs-id` sections from the bottom of the commit messages.
The following command will do that:
////////////
그리고 커밋 메시지 밑에 붙은 `git-tfs-id` 부분을 지운다.
아래 명령어를 사용하면 된다.

[source,powershell]
----
PS> git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' -- --all
----

////////////
That uses the `sed` command from the Git-bash environment to replace any line starting with ``git-tfs-id:'' with emptiness, which Git will then ignore.
////////////
이 명령어는 Git-bash 환경에 있는 `sed` 명령어를 이용해 ``git-tfs-id:''로 시작하는 모든 줄을 빈 줄로 바꾼다. 그럼 Git은 그 줄을 무시한다.

////////////
Once that's all done, you're ready to add a new remote, push all your branches up, and have your team start working from Git.
////////////
전부 완료하면 새로운 리모트 저장소를 만들고 모든 브랜치를 Push 한 다음에 팀원들과 Git으로 작업을 시작하면 된다.
