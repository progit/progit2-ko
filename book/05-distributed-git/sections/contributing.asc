[[_contributing_project]]
//////////////////////////
=== Contributing to a Project
//////////////////////////
=== 프로젝트에 기여하기

(((contributing)))
//////////////////////////
The main difficulty with describing how to contribute to a project is that there are a huge number of variations on how it's done.
Because Git is very flexible, people can and do work together in many ways, and it's problematic to describe how you should contribute – every project is a bit different.
Some of the variables involved are active contributor count, chosen workflow, your commit access, and possibly the external contribution method.
//////////////////////////
프로젝트에 기여하는 방식을 설명하는데 가장 어려운 점은 그 방식이 매우 다양하다는 점이다.
Git이 워낙 유연하게 설계됐기 때문에 사람들은 여러 가지 방식으로 사용할 수 있다. 게다가 프로젝트마다 환경이 달라서 프로젝트에 기여하는 방식을 쉽게 설명하기란 정말 어렵다.
기여하는 방식에 영향을 끼치는 몇 가지 변수가 있다. 활발히 기여하는 개발자의 수가 얼마인지, 선택한 Workflow가 무엇인지, 각 개발자에게 접근 권한을 어떻게 부여했는지, 외부에서도 기여할 수 있는지 등이 변수다.

//////////////////////////
The first variable is active contributor count – how many users are actively contributing code to this project, and how often?
In many instances, you'll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day.
This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.
Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.
How can you keep your code consistently up to date and your commits valid?
//////////////////////////
첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 얼마나 많은 개발자가 얼마나 자주 코드를 쏟아 내는가 하는 점이 활발한 개발자의 기준이다.
대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄할 것이다.
하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다.
개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge하기 어려워진다.
어떤 커밋은 다른 개발자가 이미 기여한 것으로 불필요해지기도 하고 때론 서로 충돌이 일어난다.
어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?

//////////////////////////
The next variable is the workflow in use for the project.
Is it centralized, with each developer having equal write access to the main codeline?
Does the project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved?
Are you involved in that process?
Is a lieutenant system in place, and do you have to submit your work to them first?
//////////////////////////
두 번째 변수는 프로젝트에서 선택한 저장소 운영 방식(Workflow)이다.
메인 저장소에 개발자 모두가 쓰기 권한을 가지는 중앙집중형 방식인가?
프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가?
모든 수정사항을 개발자끼리 검토하고 승인하는가?
자신도 기여 이상의 역할을 하고 있는지?
중간 관리자가 있어서 그들에게 먼저 알려야 하는가?

//////////////////////////
The next issue is your commit access.
The workflow required in order to contribute to a project is much different if you have write access to the project than if you don't.
If you don't have write access, how does the project prefer to accept contributed work?
Does it even have a policy?
How much work are you contributing at a time?
How often do you contribute?
//////////////////////////
세 번째 변수는 접근 권한이다.
'프로젝트에 쓰기 권한이 있어서 직접 쓸 수 있는가? 아니면 읽기만 가능한가?'에 따라서 프로젝트에 기여하는 방식이 매우 달라진다.
쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까?
수정사항을 적용하는 정책이 프로젝트에 있는가?
얼마나 많은 시간을 프로젝트에 할애하는가?
얼마나 자주 기여하는가?

//////////////////////////
All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.
We'll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.
//////////////////////////
이런 질문에 따라 프로젝트에 기여하는 방법과 Workflow 등이 달라진다.
간단한 것부터 복잡한 것까지 예제를 통해 각 상황을 살펴보면 실제 프로젝트에 필요한 방식을 선택할 수 있게 도움이 될 것이다.

[[_commit_guidelines]]
//////////////////////////
==== Commit Guidelines
//////////////////////////
==== 커밋 가이드라인

//////////////////////////
Before we start looking at the specific use cases, here's a quick note about commit messages.
Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier.
The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches – you can read it in the Git source code in the `Documentation/SubmittingPatches` file.
//////////////////////////
다른 것보다 먼저 커밋 메시지에 대한 주의사항을 알아보자.
커밋 메시지를 잘 작성하는 가이드라인을 알아두면 다른 개발자와 함께 일하는 데 도움이 많이 된다.
Git 프로젝트에 보면 커밋 메시지를 작성하는데 참고할 만한 좋은 팁이 많다. Git 프로젝트의 'Documentation/SubmittingPatches' 문서를 참고하자.

(((git commands, diff, check)))
//////////////////////////
First, you don't want to submit any whitespace errors.
Git provides an easy way to check for this – before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.
//////////////////////////
무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다.
Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 `git diff --check` 명령으로 공백문자에 대한 오류를 확인할 수 있다.

//////////////////////////
.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]
//////////////////////////
.`git diff --check`의 결과.
image::images/git-diff-check.png[`git diff --check`의 결과.]

//////////////////////////
If you run that command before committing, you can tell if you're about to commit whitespace issues that may annoy other developers.
//////////////////////////
커밋을 하기 전에 공백문자에 대해 검사를 하면 공백으로 불필요하게 커밋되는 것을 막고 이런 커밋으로 인해 불필요하게 다른 개발자들이 신경 쓰는 일을 방지할 수 있다.

//////////////////////////
Next, try to make each commit a logically separate changeset.
If you can, try to make your changes digestible – don't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
Even if you don't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in <<_interactive_staging>>).
The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.
This approach also makes it easier to pull out or revert one of the changesets if you need to later.
<<_rewriting_history>> describes a number of useful Git tricks for rewriting history and interactively staging files – use these tools to help craft a clean and understandable history before sending the work to someone else.
//////////////////////////
그리고 각 커밋은 논리적으로 구분되는 Changeset이다.
최대한 수정사항을 하나의 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다.
여러 가지 이슈를 한꺼번에 수정했다고 하더라도 Staging Area을 이용하여 한 커밋에 하나의 이슈만 담기도록 한다. 작업 내용을 분할하고, 각 커밋마다 적절한 메시지를 작성한다.
같은 파일의 다른 부분을 수정하는 경우에는 `git add -patch` 명령을 써서 한 부분씩 나누어 Staging Area에 저장해야 한다(관련 내용은 <<_interactive_staging> 에서 다룬다).
결과적으로 최종 프로젝트의 모습은 한 번에 커밋을 하든 다섯 번에 나누어 커밋을 하든 똑같다.
하지만, 여러 번 나누어 커밋하는 것이 다른 동료가 수정한 부분을 확인할 때나 각 커밋의 시점으로 복원해서 검토할 때 이해하기 훨씬 쉽다.
<<_rewriting_history>> 에서 이미 저장된 커밋을 다시 수정하거나 파일을 단계적으로 Staging Area에 저장하는 방법을 살펴본다. 다양한 도구를 이용해서 간단하고 이해하기 쉬운 커밋을 쌓아가야 한다.

//////////////////////////
The last thing to keep in mind is the commit message.
Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.
As a general rule, your messages should start with a single line that's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior – this is a good guideline to follow.
It's also a good idea to use the imperative present tense in these messages.
In other words, use commands.
Instead of ``I added tests for'' or ``Adding tests for,'' use ``Add tests for.''
Here is a template originally written by Tim Pope:
//////////////////////////
마지막으로 명심해야 할 점은 커밋 메시지 자체다.
좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 도움이 많이 된다.
일반적으로 커밋 메시지를 작성할 때 사용하는 규칙이 있다. 메시지의 첫 줄에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다. 다음 한 줄은 비우고 그다음 줄부터 커밋을 자세히 설명한다.
예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약조건이나 상황 등을 자세하게 요구한다. 이런 점은 따를 만한 좋은 가이드라인이다.
그리고 현재형 표현을 사용하는 것이 좋다.
명령문으로 시작하는 것도 좋은 방법이다.
예를 들어 ``I added tests for (테스트를 추가함)'' 보다는 ``Add tests for (테스트 추가)'' 와 같은 메시지를 작성한다.
아래 예제는 Tim Pope이 작성한 커밋 메시지이다.

[source,text]
//////////////////////////
-----
Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here
-----
//////////////////////////
-----
영문 50글자 이하의 간략한 수정 요약

자세한 설명. 영문 72글자 이상이 되면
줄 바꿈을 하고 이어지는 내용을 작성한다.
특정 상황에서는 첫 번째 줄이 이메일
메시지의 제목이 되고 나머지는 메일
내용이 된다. 간략하게 요약하고 넣는 빈
줄은 자세한 설명을 아예 쓰지 않는 한
매우 중요하다.

이어지는 내용도 한 줄 띄우고 쓴다.

  - 목록 표시도 사용할 수 있다.

  - 보통 '-' 나 '*' 표시를 사용해서 목록을 표현하고
    표시 앞에 공백 하나, 각 목록 사이에는 빈 줄
    하나를 넣는데 상황에 따라 다르다.
-----

//////////////////////////
If all your commit messages look like this, things will be a lot easier for you and the developers you work with.
The Git project has well-formatted commit messages – try running `git log --no-merges` there to see what a nicely formatted project-commit history looks like.
//////////////////////////
메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 자신에게도 매우 유용하다.
Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 프로젝트를 내려받아서 `git log --no-merges` 명령으로 꼭 살펴보기를 권한다.

//////////////////////////
In the following examples, and throughout most of this book, for the sake of brevity this book doesn't have nicely-formatted messages like this; instead, we use the `-m` option to `git commit`.
Do as we say, not as we do.
//////////////////////////
이 책에서 설명하는 예제의 커밋 메시지는 시간 관계상 위와 같이 아주 멋지게 쓰지 않았다. `git commit` 명령에서 `-m` 옵션을 사용하여 간단하게 적는다.
하지만! 저자처럼 하지 말고 시키는 대로 하셔야 한다.

[[_private_team]]
//////////////////////////
==== Private Small Team
//////////////////////////
==== 비공개 소규모 팀

(((contributing, private small team)))
//////////////////////////
The simplest setup you're likely to encounter is a private project with one or two other developers.
``Private,'' in this context, means closed-source – not accessible to the outside world.
You and the other developers all have push access to the repository.
//////////////////////////
두세 명으로 이루어진 비공개 프로젝트가 가장 간단한 프로젝트일 것이다.
``비공개''라고 함은 소스코드가 공개되지 않은 것을 말하는 것이지 외부에서 접근할 수 없는 것을 말하지 않는다.
모든 개발자는 공유하는 저장소에 쓰기 권한이 있어야 한다.

//////////////////////////
In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.
You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.
Let's see what it might look like when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with `...` in these examples to shorten them somewhat.)
//////////////////////////
이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다.
물론 Git이 가진 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다. 가장 큰 차이점은 서버가 아닌 클라이언트 쪽에서 Merge한다는 점이다.
두 개발자가 저장소를 공유하는 시나리오를 살펴보자.
개발자 John씨는 저장소를 Clone하고 파일을 수정하고 나서 로컬에 커밋한다
(예제에서 Git이 출력하는 메시지중 일부는 `...`으로 줄이고 생략했다).

[source,console]
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
The second developer, Jessica, does the same thing – clones the repository and commits a change:
//////////////////////////
개발자 Jessica씨도 저장소를 Clone하고 나서 파일을 하나 새로 추가하고 커밋한다.

[source,console]
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

//////////////////////////
Now, Jessica pushes her work up to the server:
//////////////////////////
Jessica씨는 서버에 커밋을 Push한다.

[source,console]
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

//////////////////////////
John tries to push his change up, too:
//////////////////////////
John씨도 서버로 커밋을 Push하려고 한다.

[source,console]
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

//////////////////////////
John isn't allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you're used to Subversion, because you'll notice that the two developers didn't edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
John has to fetch Jessica's changes and merge them in before he will be allowed to push:
//////////////////////////
Jessica씨의 Push는 성공했지만, John씨의 커밋은 서버에서 거절된다.
Subversion을 사용했던 사람은 이 부분을 이해하는 것이 중요하다.
같은 파일을 수정한 것도 아닌데 왜 Push가 거절되는 걸까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만, Git은 로컬에서 먼저 Merge해야 한다.
John씨는 Push하기 전에 Jessica씨가 수정한 커밋을 Fetch하고 Merge한다.

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

//////////////////////////
At this point, John's local repository looks something like this:
//////////////////////////
Fetch하고 나면 John씨의 로컬 저장소는 아래와 같이 된다.

//////////////////////////
.John's divergent history.
image::images/small-team-1.png[John's divergent history.]
//////////////////////////
.Fetch하고 난 John씨의 저장소.
image::images/small-team-1.png[Fetch하고 난 John씨의 저장소.]

//////////////////////////
John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:
//////////////////////////
John씨는 Jessica씨가 저장소로 Push했던 코드를 로컬 저장소에 가져왔다. 하지만, Push하기 전에 Fetch한 브랜치를 Merge해야 한다.

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

//////////////////////////
The merge goes smoothly – John's commit history now looks like this:
//////////////////////////
Merge가 잘 이루어지면 John씨의 브랜치는 아래와 같은 상태가 된다.

//////////////////////////
.John's repository after merging `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]
//////////////////////////
.`origin/master` 브랜치를 Merge하고 난 후, John씨의 저장소.
image::images/small-team-2.png[`origin/master` 브랜치를 Merge하고 난 후, John씨의 저장소.]

//////////////////////////
Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:
//////////////////////////
John씨는 Merge하고 나서 자신이 작업한 코드가 제대로 동작하는지 확인한다. 그 후에 공유하는 저장소에 Push한다.

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

//////////////////////////
Finally, John's commit history looks like this:
//////////////////////////
이제 John씨의 저장소는 아래와 같이 되었다.

//////////////////////////
.John's history after pushing to the `origin` server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]
//////////////////////////
.Push하고 난 후 John씨의 저장소.
image::images/small-team-3.png[Push하고 난 후 John씨의 저장소.]

//////////////////////////
In the meantime, Jessica has been working on a topic branch.
She's created a topic branch called `issue54` and done three commits on that branch.
She hasn't fetched John's changes yet, so her commit history looks like this:
//////////////////////////
동시에 Jessica씨는 토픽 브랜치를 하나 만든다.
issue54 브랜치를 만들고 세 번에 걸쳐서 커밋한다.
아직 John씨의 커밋을 Fetch하지 않은 상황이기 때문에 아래와 같은 상황이 된다.

//////////////////////////
.Jessica's topic branch.
image::images/small-team-4.png[Jessica's topic branch.]
//////////////////////////
.Jessica씨 저장소의 토픽 브랜치.
image::images/small-team-4.png[Jessica씨 저장소의 토픽 브랜치.]

//////////////////////////
Jessica wants to sync up with John, so she fetches:
//////////////////////////
Jessica씨는 John씨의 작업을 적용하려면 Fetch해야 한다.

[source,console]
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

//////////////////////////
That pulls down the work John has pushed up in the meantime.
Jessica's history now looks like this:
//////////////////////////
위 명령으로 John씨가 Push한 커밋을 모두 내려받는다.
그러면 Jessica씨의 저장소는 아래와 같은 상태가 된다.

//////////////////////////
.Jessica's history after fetching John's changes.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]
//////////////////////////
.John씨의 커밋을 Fetch한 후 Jessica씨의 저장소.
image::images/small-team-5.png[John씨의 커밋을 Fetch한 후 Jessica씨의 저장소.]

//////////////////////////
Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work so that she can push.
She runs `git log` to find out:
//////////////////////////
이제 orgin/master와 Merge할 차례다.
Jessica씨는 토픽 브랜치 작업을 마치고 어떤 내용이 Merge되는지 `git log` 명령으로 확인한다.

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

//////////////////////////
The `issue54..origin/master` syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`). We'll go over this syntax in detail in <<_commit_ranges>>.
//////////////////////////
`issue54..origin/master` 문법은 히스토리를 검색할 때 뒤의 브랜치(`origin/master`)에 속한 커밋 중 앞의 브랜치(`issue54`)에 속하지 않은 커밋을 검색하는 문법이다. 자세한 내용은 <<_commit_ranges>>에서 다룬다.

//////////////////////////
For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in. If she merges `origin/master`, that is the single commit that will modify her local work.
//////////////////////////
앞의 명령에 따라 히스토리를 검색한 결과 John씨가 생성하고 Jessica씨가 Merge하지 않은 커밋을 하나 찾았다. `origin/master` 브랜치를 Merge하게 되면 검색된 커밋 하나가 로컬 작업에 Merge될 것이다.

//////////////////////////
Now, Jessica can merge her topic work into her master branch, merge John's work (`origin/master`) into her `master` branch, and then push back to the server again.
First, she switches back to her master branch to integrate all this work:
//////////////////////////
Merge할 내용을 확인한 Jessica씨는 자신이 작업한 내용과 John씨가 Push한 작업(`origin/master`)을 `master` 브랜치에 Merge하고 Push한다.
모든 내용을 합치기 전에 우선 `master` 브랜치를 Checkout한다.

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

//////////////////////////
She can merge either `origin/master` or `issue54` first – they're both upstream, so the order doesn't matter.
The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
She chooses to merge in `issue54` first:
//////////////////////////
`origin/master`, `issue54` 모두 `master`보다 Fast-forward된 브랜치이기 때문에 둘 중에 무엇을 먼저 Merge하든 상관이 없다.
물론 어떤 것을 먼저 Merge하느냐에 따라 히스토리 순서는 달라지지만, 최종 결과는 똑같다.
Jessica씨는 먼저 `issue54` 브랜치를 Merge한다.

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

//////////////////////////
No problems occur; as you can see it was a simple fast-forward.
Now Jessica merges in John's work (`origin/master`):
//////////////////////////
보다시피 Fast-forward Merge이기 때문에 별 문제 없이 실행된다.
다음은 John씨의 커밋(`origin/master`)을 Merge한다.

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
Everything merges cleanly, and Jessica's history looks like this:
//////////////////////////
위와 같이 Merge가 잘 되면 그림 아래와 같은 상태가 된다.

//////////////////////////
.Jessica's history after merging John's changes.
image::images/small-team-6.png[Jessica's history after merging John's changes.]
//////////////////////////
.John씨의 커밋을 Merge 후 Jessica씨의 저장소.
image::images/small-team-6.png[John씨의 커밋을 Merge 후 Jessica씨의 저장소.]

//////////////////////////
Now `origin/master` is reachable from Jessica's `master` branch, so she should be able to successfully push (assuming John hasn't pushed again in the meantime):
//////////////////////////
`origin/master` 브랜치가 Jessica씨의 `master` 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John씨가 그 사이에 Push하지 않았다면).

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

//////////////////////////
Each developer has committed a few times and merged each other's work successfully.
//////////////////////////
두 개발자의 커밋과 Merge가 성공적으로 이루어지고 난 후의 결과는 아래와 같다.

//////////////////////////
.Jessica's history after pushing all changes back to the server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]
//////////////////////////
.Jessica씨가 서버로 Push하고 난 후의 저장소.
image::images/small-team-7.png[Jessica씨가 서버로 Push하고 난 후의 저장소.]

//////////////////////////
That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your master branch when it's ready to be integrated.
When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.
The general sequence is something like this:
//////////////////////////
매우 간단한 상황의 예제를 살펴보았다.
토픽 브랜치에서 수정하고 로컬의 `master` 브랜치에 Merge한다.
작업한 내용을 프로젝트의 공유 저장소에 Push하고자 할 때에는 우선 `origin/master` 브랜치를 Fetch하고 Merge한다. 그리고 나서 Merge한 결과를 다시 서버로 Push한다.
이런 Workflow가 일반적이며 아래와 같이 나타낼 수 있다.

//////////////////////////
.General sequence of events for a simple multiple-developer Git workflow.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]
//////////////////////////
.여러 개발자가 Git을 사용하는 Workflow.
image::images/small-team-flow.png[여러 개발자가 Git을 사용하는 Workflow.]

//////////////////////////
==== Private Managed Team
//////////////////////////
==== 비공개 대규모 팀

(((contributing, private managed team)))
//////////////////////////
In this next scenario, you'll look at contributor roles in a larger private group.
You'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.
//////////////////////////
이제 비공개 대규모 팀에서의 역할을 살펴보자.
이런 상황에는 보통 팀을 여러 개로 나눈다. 그래서 각각의 작은 팀이 서로 어떻게 하나로 Merge하는지를 살펴본다.

//////////////////////////
Let's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.
//////////////////////////
John씨와 Jessica씨는 어떤 기능을 함께 작업하게 됐다. 물론 각각 다른 일도 한다.
이런 상황이라면 회사는 Integration-manager Workflow를 선택하는 게 좋다. 작은 팀이 수행한 결과물은 Integration-Manager가 Merge하고 공유 저장소의 master 브랜치를 업데이트한다.
팀마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull해서 Merge한다.

//////////////////////////
Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on `featureA` first.
She creates a new branch for the feature and does some work on it there:
//////////////////////////
두 팀에 모두 속한 Jessica씨의 작업 순서를 살펴보자.
우선 Jessica씨는 저장소를 Clone하고 `featureA` 작업을 먼저 한다.
`featureA` 브랜치를 만들고 수정하고 커밋한다.

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

//////////////////////////
At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.
Jessica doesn't have push access to the `master` branch – only the integrators do – so she has to push to another branch in order to collaborate with John:
//////////////////////////
이 수정한 부분을 John씨와 공유해야 한다. 공유하려면 우선 `featureA` 브랜치를 서버로 Push한다.
Integration-Manager만 `master` 브랜치를 업데이트할 수 있기 때문에 master 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다.

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

//////////////////////////
Jessica e-mails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:
//////////////////////////
Jessica씨는 자신이 한 일을 `featureA` 라는 브랜치로 Push했다는 이메일을 John씨에게 보낸다.
John씨의 피드백을 기다리는 동안 Jessica씨는 Josie씨와 함께 하는 `featureB` 작업을 하기로 한다.
서버의 `master` 브랜치를 기반으로 새로운 브랜치를 하나 만든다.

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

//////////////////////////
Now, Jessica makes a couple of commits on the `featureB` branch:
//////////////////////////
몇 가지 작업을 하고 `featureB` 브랜치에 커밋한다.

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

//////////////////////////
Jessica's repository looks like this:
//////////////////////////
그럼 Jessica씨의 저장소는 그림 아래와 같다.

//////////////////////////
.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]
//////////////////////////
.Jessica씨의 저장소.
image::images/managed-team-1.png[Jessica씨의 저장소.]

//////////////////////////
She's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:
//////////////////////////
작업을 마치고 Push하려고 하는데 Jesie씨가 이미 일부 작업을 하고 서버에 `featureBee` 브랜치로 Push했다는 이메일을 보내왔다.
Jessica씨는 Jesie씨의 작업을 먼저 Merge해야만 Push할 수 있다.
Merge하기 위해서 우선 `git fetch`로 Fetch한다.

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

//////////////////////////
Jessica can now merge this into the work she did with `git merge`:
//////////////////////////
Fetch해 온 브랜치를 `git merge` 명령으로 Merge한다.

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

//////////////////////////
There is a bit of a problem – she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:
//////////////////////////
Push하려고 하는데 작은 문제가 생겼다. Jessica씨는 `featureB` 브랜치에서 작업을 했는데 서버에는 브랜치가 `featureBee` 라는 이름으로 되어 있다.
그래서 `git push` 명령으로 Push할 때 로컬 브랜치 featureB 뒤에 콜론(:)과 함께 서버 브랜치 이름을 직접 지정해 준다.

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

//////////////////////////
This is called a _refspec_.
See <<_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.
//////////////////////////
이것은 _refspec_ 이란 것을 사용하는 것인데
<<_refspec>> 에서 자세하게 설명한다.
명령에서 사용한 `-u` 옵션은 `--set-upstream` 옵션의 짧은 표현인데 브랜치를 추적하도록 설정해서 이후 Push나 Pull을 할 때 좀 더 편하게 사용할 수 있다.

//////////////////////////
Next, John e-mails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:
//////////////////////////
John씨가 몇 가지 작업을 하고 나서 `featureA` 에 Push했고 확인해 달라는 내용의 이메일을 보내왔다.
Jessica씨는 `git fetch`로 Push한 작업을 Fetch한다.

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

//////////////////////////
Then, she can see what has been changed with `git log`:
//////////////////////////
어떤 것이 업데이트됐는지 `git log` 명령으로 확인한다.

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

//////////////////////////
Finally, she merges John's work into her own `featureA` branch:
//////////////////////////
확인을 마치면 로컬의 `featureA` 브랜치로 Merge한다.

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

//////////////////////////
Jessica wants to tweak something, so she commits again and then pushes this back up to the server:
//////////////////////////
Jessica씨는 일부 수정하고, 수정한 내용을 다시 서버로 Push한다.

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

//////////////////////////
Jessica's commit history now looks something like this:
//////////////////////////
위와 같은 작업을 마치고 나면 Jessica씨의 저장소는 아래와 같은 모습이 된다.

//////////////////////////
.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]
//////////////////////////
.마지막 Push하고 난 후의 Jessica씨의 저장소.
image::images/managed-team-2.png[마지막 Push하고 난 후의 Jessica씨의 저장소.]

//////////////////////////
Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:
//////////////////////////
그럼 `featureA` 와 `featureBee` 브랜치가 프로젝트의 메인 브랜치로 Merge할 준비가 되었다고 Integration-Manager에게 알려준다.
Integration-Manager가 두 브랜치를 모두 Merge하고 난 후에 메인 브랜치를 Fetch하면 아래와 같은 모양이 된다.

//////////////////////////
.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]
//////////////////////////
.두 브랜치가 메인 브랜치에 Merge된 후의 저장소.
image::images/managed-team-3.png[두 브랜치가 메인 브랜치에 Merge된 후의 저장소.]

//////////////////////////
Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:
//////////////////////////
수많은 팀의 작업을 동시에 진행하고 나중에 Merge하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다.
팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다.
아래는 이런 Workflow을 나타내고 있다.

//////////////////////////
.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]
//////////////////////////
.Managed 팀의 Workflow.
image::images/managed-team-flow.png[Managed 팀의 Workflow.]

[[_public_project]]
//////////////////////////
==== Forked Public Project
//////////////////////////
==== 공개 프로젝트 Fork

(((contributing, public small project)))
//////////////////////////
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via e-mail.
//////////////////////////
비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다.
공개 팀을 운영할 때에는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지는 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다.
Fork를 지원하는 Git 호스팅에서 Fork를 통해 프로젝트에 기여하는 법을 예제를 통해 살펴본다.
Git 호스팅 사이트(Github, BitBucket, Google Code, repo.or.cz 등) 대부분은 Fork 기능을 지원하며 프로젝트 관리자는 보통 Fork하는 것으로 프로젝트를 운영한다.
다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴본다.

//////////////////////////
First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
The sequence looks basically like this:
//////////////////////////
우선 처음 할 일은 메인 저장소를 Clone 하는 것이다. 그리고 나서 토픽 브랜치를 만들고 일정 부분 기여한다.
그 순서는 아래와 같다.

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
//////////////////////////
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<_rewriting_history>> for more information about interactive rebasing.
====
//////////////////////////
====
`rebase -i` 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. <<_rewriting_history>> 에서 대화식으로 Rebase하는 방법을 살펴본다.
====

//////////////////////////
When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named `myfork`:
//////////////////////////
일단 프로젝트의 웹사이트로 가서 ``Fork'' 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 원래 저장소에 Push할 수 있다.
그 저장소를 로컬 저장소의 리모트 저장소로 등록한다. 예를 들어 myfork로 등록한다.

[source,console]
-----
$ git remote add myfork (url)
-----

//////////////////////////
Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:
//////////////////////////
자 이제 등록한 리모트 저장소에 Push한다.
작업하던 것을 로컬 저장소의 master 브랜치에 Merge한 후 Push하는 것보다 리모트 브랜치에 바로 Push를 하는 방식이 훨씬 간단하다.
이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함시키고 싶지 않을 때 토픽 브랜치를 Merge하기 이전 상태로 master 브랜치를 되돌릴 필요가 없기 때문이다.
관리자가 토픽 브랜치를 Merge하든 Rebase하든 cherry-pick하든지 간에 결국 다시 관리자의 저장소를 Pull할 때에는 토픽 브랜치의 내용이 들어 있을 것이다.

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
//////////////////////////
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and e-mail the output to the project maintainer manually.
//////////////////////////
Fork한 저장소에 Push하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다.
이것을 'Pull Request'라고 한다. Git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 `git request-pull` 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 "pull request" 버튼은 자동으로 메시지를 만들어 주는데 관련 내용은 <<_github>> 에서 살펴볼 수 있다..

//////////////////////////
The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:
//////////////////////////
`request-pull` 명령은 아규먼트를 두 개 입력받는다. 첫 번째 아규먼트는 작업한 토픽 브랜치의 Base 브랜치이다. 두 번째는 토픽 브랜치가 위치한 저장소 URL인데 위에서 등록한 리모트 저장소 이름을 적을 수 있다. 이 명령은 토픽 브랜치 수정사항을 요약한 내용을 결과로 보여준다.
예를 들어 Jessica씨가 John씨에게 Pull 요청을 보내는 상황을 살펴보자. Jessica씨는 토픽 브랜치에 두 번 커밋을 하고 Fork한 저장소에 Push했다. 그리고 아래와 같이 실행한다.

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40.
  John Smith (1).
        added a new function

are available in the git repository at.

  git://githost/simplegit.git featureA

Jessica Smith (2).
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

//////////////////////////
The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.
//////////////////////////
관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 갈라져 나온 것인지, 어떤 커밋이 있는 지, Pull하려면 어떤 저장소에 접근해야 하는지에 대한 내용이 들어 있다.

//////////////////////////
On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:
//////////////////////////
프로젝트 관리자가 아니라고 해도 보통 `origin/master`를 추적하는 `master` 브랜치는 가지고 있다. 그래도 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다.
토픽 브랜치를 만들어서 주제별로 독립적으로 일을 하는 동안에도 주 저장소의 `master` 브랜치는 계속 수정된다. 하지만 주 저장소의 브랜치의 최근 커밋 이후로 Rebase하면 깨끗하게 Merge할 수 있다.
그리고 다른 주제의 일을 하려고 할 때는 앞서 Push한 토픽 브랜치에서 시작하지 말고 주 저장소의 `master` 브랜치로부터 만들어야 한다.

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

//////////////////////////
Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:
//////////////////////////
그림 5-16 처럼 각 토픽은 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 수정하고 Rebase할 수 있다.

//////////////////////////
.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]
//////////////////////////
.featureB 수정작업이 끝난 직후 저장소의 모습.
image::images/public-small-1.png[featureB 수정작업이 끝난 직후 저장소의 모습.]

//////////////////////////
Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:
//////////////////////////
프로젝트 관리자가 사람들의 수정사항을 Merge하고 나서 Jessica씨의 브랜치를 Merge하려고 할 때 충돌이 날 수도 있다.
그러면 Jessica씨가 자신의 브랜치를 `origin/master`에 Rebase해서 충돌을 해결하고 다시 Pull Request을 보낸다.

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

//////////////////////////
This rewrites your history to now look like <<psp_b>>.
//////////////////////////
위 명령들을 실행하고 나면 히스토리는 아래와 같아진다.

[[psp_b]]
//////////////////////////
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]
//////////////////////////
.FeatureA에 대한 Rebase가 적용된 후의 모습.
image::images/public-small-2.png[CFeatureA에 대한 Rebase가 적용된 후의 모습.]

//////////////////////////
Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).
//////////////////////////
브랜치를 Rebase해 버렸기 때문에 Push할 때 `-f` 옵션을 주고 강제로 기존 서버에 있던 `featureA` 브랜치의 내용을 덮어 써야 한다.
아니면 새로운 브랜치를(예를 들어 `featureAv2`) 서버에 Push해도 된다.

//////////////////////////
Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:
//////////////////////////
또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자는 `featureB` 브랜치의 내용은 좋지만, 상세 구현은 다르게 하고 싶다. 관리자는 `featureB` 담당자에게 상세구현을 다르게 해달라고 요청한다.
`featureB` 담당자는 하는 김에 `featureB` 브랜치를 프로젝트의 최신 `master` 브랜치 기반으로 옮긴다.
먼저 `origin/master` 브랜치에서 `featureBv2` 브랜치를 새로 하나 만들고, `featureB`의 커밋들을 모두 Squash해서 Merge하고, 만약 충돌이 나면 해결하고, 상세 구현을 수정하고, 새 브랜치를 Push한다.

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

//////////////////////////
The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you're on.
The `--no-commit` option tells Git not to automatically record a commit.
This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
//////////////////////////
`--squash` 옵션은 현재 브랜치에 Merge할 때 해당 브랜치의 커밋을 모두 하나의 커밋으로 합쳐서 Merge한다.
`--no-commit` 옵션을 주면 Git은 Merge하고 나서 자동으로 커밋하지 않는다.
다른 브랜치의 수정사항을 통째로 새로운 브랜치에 Merge하고 나서 좀 더 수정하고 커밋 하나를 새로 만든다.

//////////////////////////
Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.
//////////////////////////
수정을 마치면 관리자에게 `featureBv2` 브랜치를 확인해 보라고 메시지를 보낸다.

//////////////////////////
.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]
//////////////////////////
.featureBv2 브랜치를 커밋한 이후 저장소 모습.
image::images/public-small-3.png[featureBv2 브랜치를 커밋한 이후 저장소 모습.]

[[_project_over_email]]
//////////////////////////
==== Public Project over E-Mail
//////////////////////////
==== 대규모 공개 프로젝트와 이메일을 통한 관리

(((contributing, public large project)))
//////////////////////////
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.
//////////////////////////
대규모 프로젝트는 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다.
오래된 대규모 프로젝트는 대부분 메일링리스트를 통해서 Patch를 받아들이는데 예제를 통해 살펴본다.

//////////////////////////
The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:
//////////////////////////
토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만,
Patch를 제출하는 방식이 다르다.
프로젝트를 Fork 하여 Push하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출한다.

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
//////////////////////////
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly.
//////////////////////////
커밋을 두 번 하고 메일링리스트에 보내 보자.
`git format-patch` 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성한다. 각 커밋은 하나씩 메일 메시지로 생성되는데 커밋 메시지의 첫 번째 줄이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다.
이 방식은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있어서 좋다. 메일 속에는 커밋의 모든 내용이 포함된다. 메일에 포함된 Patch를 적용하는 것은 다음 절에서 살펴본다.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

//////////////////////////
The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:
//////////////////////////
`format-patch` 명령을 실행하면 생성한 파일 이름을 보여준다.
`-M` 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다.
각 파일의 내용은 아래와 같다.

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

//////////////////////////
You can also edit these patch files to add more information for the e-mail list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.
//////////////////////////
메일링리스트에 메일을 보내기 전에 각 Patch 파일을 손으로 고칠 수 있다.
`---` 줄과 Patch가 시작되는 줄(`diff --git`로 시작하는 줄) 사이에 내용을 추가하면 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.

//////////////////////////
To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.
//////////////////////////
특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다.
붙여 넣기로 위의 내용이 그대로 들어가지 않는 메일 프로그램도 있다. 사용자 편의를 위해 공백이나 줄 바꿈 문자 등을 넣어 주는 메일 프로그램은 원본 그대로 들어가지 않는다.
다행히 Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보낸다.
저자가 사용하는 방법으로 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 `Documentation/SubmittingPatches` 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램으로 메일을 보내는 방법을 설명한다.

(((git commands, config)))(((email)))
//////////////////////////
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:
//////////////////////////
메일을 보내려면 먼저 `~/.gitconfig` 파일에서 이메일 부분 설정한다.
`git config` 명령으로 추가할 수도 있고 직접 파일을 열어서 추가할 수도 있다. 아무튼, 아래와 같이 설정을 한다.

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

//////////////////////////
If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:
//////////////////////////
IMAP 서버가 SSL을 사용하지 않으면 마지막 두 줄은 필요 없고 host에서 `imaps://` 대신 `imap://`로 한다.
이렇게 설정하면 `git send-email` 명령으로 Patch 파일을 IMAP 서버의 Draft 폴더에 이메일로 보낼 수 있다.

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

//////////////////////////
Then, Git spits out a bunch of log information looking something like this for each patch you're sending:
//////////////////////////
명령을 실행하면 아래와 같이 서버로 Patch를 보내는 내용이 화면에 나타난다.

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says.
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

//////////////////////////
At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.
//////////////////////////
이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.

//////////////////////////
==== Summary
//////////////////////////
==== 요약

//////////////////////////
This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
//////////////////////////
이번 절에서는 다양한 Workflow에 따라 Git을 어떻게 사용하는 지 살펴보고 그에 필요한 도구들을 설명했다.
다음 절에서는 동전의 뒷면인 프로젝트를 운영하는 방법에 대하여 살펴본다.
즉 친절한 Dictator나 Integration-Manager가 되어 보는 것이다.
