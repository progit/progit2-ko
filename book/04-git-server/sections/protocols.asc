//////////////////////////
=== The Protocols
//////////////////////////
=== 프로토콜

//////////////////////////
Git can use four distinct protocols to transfer data: Local, HTTP, Secure Shell (SSH) and Git.
Here we'll discuss what they are and in what basic circumstances you would want (or not want) to use them.
//////////////////////////
Git은 Local, HTTP, SSH, Git 이렇게 네 가지의 프로토콜을 사용할 수 있다.
이 절에서는 각각 어떤 경우에 유용한지 살펴본다.

//////////////////////////
==== Local Protocol
//////////////////////////
==== 로컬 프로토콜

(((protocols, local)))
//////////////////////////
The most basic is the _Local protocol_, in which the remote repository is in another directory on the same host.
This is often used if everyone on your team has access to a shared filesystem such as an NFS mount, or in the less likely case that everyone logs in to the same computer.
The latter wouldn't be ideal, because all your code repository instances would reside on the same computer, making a catastrophic loss much more likely.
//////////////////////////
가장 기본적인 것이 _로컬 프로토콜_ 이다. 리모트 저장소가 단순히 같은 시스템의 다른 디렉토리에 있을 때 사용한다.
팀원들이 전부 한 시스템에 로그인하여 개발하거나 아니면 NFS같은 것으로 파일시스템을 공유하고 있을 때 사용한다.
이런 상황은 문제가 될 수 있다. 모든 저장소가 한 시스템에 있기 때문에 한순간에 모두 잃을 수 있다.

//////////////////////////
If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository.
To clone a repository like this, or to add one as a remote to an existing project, use the path to the repository as the URL.
For example, to clone a local repository, you can run something like this:
//////////////////////////
공유 파일시스템을 마운트했을 때는 로컬 저장소를 사용하는 것처럼 Clone 하고 Push 하고 Pull 하면 된다.
일단 저장소를 Clone 하거나 프로젝트에 리모트 저장소로 추가한다. 추가할 때 URL 자리에 저장소의 경로를 사용한다.
예를 들어 아래와 같이 로컬 저장소를 Clone 한다.

[source,console]
----
$ git clone /srv/git/project.git
----

//////////////////////////
Or you can do this:
//////////////////////////
아래처럼도 가능하다:

[source,console]
----
$ git clone file:///srv/git/project.git
----

//////////////////////////
Git operates slightly differently if you explicitly specify `file://` at the beginning of the URL.
If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.
If you specify `file://`, Git fires up the processes that it normally uses to transfer data over a network, which is generally much less efficient.
The main reason to specify the `file://` prefix is if you want a clean copy of the repository with extraneous references or objects left out -- generally after an import from another VCS or something similar (see <<ch10-git-internals#ch10-git-internals>> for maintenance tasks).
We'll use the normal path here because doing so is almost always faster.
//////////////////////////
Git은 파일 경로를 직접 쓸 때와 `file://` 로 시작하는 URL을 사용할 때를 약간 다르게 처리한다.
디렉토리 경로를 그대로 사용하면 Git은 필요한 파일을 직접 복사하거나 하드 링크를 사용한다.
하지만 `file://` 로 시작하면 Git은 네트워크를 통해서 데이터를 전송할 때처럼 프로세스를 별도로 생성하여 처리한다. 이 프로세스로 데이터를 전송하는 것은 효율이 좀 떨어지지만 그래도 `file://` 를 사용하는 이유가 있다.
이것은 외부 Refs나 개체들이 포함된 저장소의 복사본을 깨끗한 상태로 남겨두고자 함이다. 보통은 다른 버전 관리 시스템들에서 임포트한 후에 사용한다(<<ch10-git-internals#ch10-git-internals>>에서 자세히 다룬다).
여기서는 속도가 빠른 디렉토리 경로를 사용한다.

//////////////////////////
To add a local repository to an existing Git project, you can run something like this:
//////////////////////////
이미 가진 Git 프로젝트에는 아래와 같이 로컬 저장소를 추가한다.

[source,console]
----
$ git remote add local_proj /srv/git/project.git
----

//////////////////////////
Then, you can push to and pull from that remote via your new remote name `local_proj` as though you were doing so over a network.
//////////////////////////
그러면 네트워크에 있는 리모트 저장소처럼 `local_proj` 이름으로 리모트처럼 Push 하거나 Pull 할 수 있다.

//////////////////////////
===== The Pros
//////////////////////////
===== 장점

//////////////////////////
The pros of file-based repositories are that they're simple and they use existing file permissions and network access.
If you already have a shared filesystem to which your whole team has access, setting up a repository is very easy.
You stick the bare repository copy somewhere everyone has shared access to and set the read/write permissions as you would for any other shared directory.
We'll discuss how to export a bare repository copy for this purpose in <<ch04-git-on-the-server#_getting_git_on_a_server>>.
//////////////////////////
파일 기반 저장소의 장점은 간단하다는 것이다. 기존에 있던 네트워크나 파일의 권한을 그대로 사용하기 때문에 설정하기 쉽다.
이미 팀 전체가 접근할 수 있는 파일시스템을 가지고 있다면 저장소를 아주 쉽게 구성할 수 있다.
다른 디렉토리를 공유할 때처럼 모든 동료가 읽고 쓸 수 있는 공유 디렉토리에 Bare 저장소를 만들면 된다.
다음 절인 <<ch04-git-on-the-server#_getting_git_on_a_server>>에서 Bare 저장소를 만드는 방법을 살펴볼 것이다.

//////////////////////////
This is also a nice option for quickly grabbing work from someone else's working repository.
If you and a co-worker are working on the same project and they want you to check something out, running a command like `git pull /home/john/project` is often easier than them pushing to a remote server and you subsequently fetching from it.
//////////////////////////
또한, 동료가 작업하는 저장소에서 한 일을 바로 가져오기에도 좋다.
만약 함께 프로젝트를 하는 동료가 자신이 한 일을 당신이 확인해 줬으면 한다. 이럴 때 `git pull /home/john/project` 처럼 명령어를 실행시켜서 매우 쉽게 동료의 코드를 가져올 수 있다. 그 동료가 서버에 Push 하고 당신이 다시 Pull 할 필요 없다.

//////////////////////////
===== The Cons
//////////////////////////
===== 단점

//////////////////////////
The cons of this method are that shared access is generally more difficult to set up and reach from multiple locations than basic network access.
If you want to push from your laptop when you're at home, you have to mount the remote disk, which can be difficult and slow compared to network-based access.
//////////////////////////
다양한 상황에서 접근할 수 있도록 디렉토리를 공유하는 것 자체가 일반적으로 어렵다.
집에 있을 때 Push 해야 하면 리모트 저장소가 있는 디스크를 마운트해야 하는데 이것은 다른 프로토콜을 이용하는 방법보다 느리고 어렵다.

//////////////////////////
It's important to mention that this isn't necessarily the fastest option if you're using a shared mount of some kind.
A local repository is fast only if you have fast access to the data.
A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.
//////////////////////////
게다가 파일시스템을 마운트해서 사용하는 중이라면 별로 빠르지도 않다.
로컬 저장소는 데이터를 빠르게 읽을 수 있을 때만 빠르다.
NFS에 있는 저장소에 Git을 사용하는 것은 보통 같은 서버에 SSH로 접근하는 것보다 느리다.

//////////////////////////
Finally, this protocol does not protect the repository against accidental damage.
Every user has full shell access to the “remote” directory, and there is nothing preventing them from changing or removing internal Git files and corrupting the repository.
//////////////////////////
마지막으로 이 프로토콜은 저장소에 우발적인 사고가 발생하지 않도록 보호해주지 않는다.
모든 사용자는 쉘에서 “리모트” 디렉토리에 무슨 짓이든지 할 수 있다. 누군가 저장소에 침범해서 Git 내부 파일을 삭제하고 변경하지 못하도록 하는 장치가 없다.

//////////////////////////
==== The HTTP Protocols
//////////////////////////
==== HTTP 프로토콜

//////////////////////////
Git can communicate over HTTP using two different modes.
Prior to Git 1.6.6, there was only one way it could do this which was very simple and generally read-only.
In version 1.6.6, a new, smarter protocol was introduced that involved Git being able to intelligently negotiate data transfer in a manner similar to how it does over SSH.
In the last few years, this new HTTP protocol has become very popular since it's simpler for the user and smarter about how it communicates.
The newer version is often referred to as the _Smart_ HTTP protocol and the older way as _Dumb_ HTTP.
We'll cover the newer Smart HTTP protocol first.
//////////////////////////
Git은 HTTP로 통신할 때, 서로 다른 두 방법으로 HTTP를 사용할 수 있다.
1.6.6 이전 버전에서는 읽기만 가능한 단순한 방법밖에 사용할 수 없었다.
1.6.6 버전부터는 똑똑한 프로토콜을 사용할 수 있다.
이 프로토콜은 Git 데이터를 전송할 때 SSH처럼 서로 협상한다.
새로운 HTTP 프로토콜은 사용이 쉽고 기능도 좋아서 많은 사람들이 사용하고 있다.
이 프로토콜을 보통 _스마트_ HTTP 프로토콜이라 하고 예전의 HTTP 프로토콜을 _멍청한_ HTTP 프로토콜이라고 한다.
먼저 스마트 HTTP 프로토콜을 설명한다.

//////////////////////////
===== Smart HTTP
//////////////////////////
===== 스마트 HTTP

(((protocols, smart HTTP)))
//////////////////////////
Smart HTTP operates very similarly to the SSH or Git protocols but runs over standard HTTPS ports and can use various HTTP authentication mechanisms, meaning it's often easier on the user than something like SSH, since you can use things like username/password authentication rather than having to set up SSH keys.
//////////////////////////
스마트 HTTP 프로토콜은 SSH나 Git 프로토콜처럼 통신한다. 다만 HTTP나 HTTPS 포트를 이용해 통신하고 다양한 HTTP 인증 방식을 사용한다는 것이 다르다. SSH는 키를 발급하고 관리해야 하는 번거로움이 있지만, HTTP는 사용자이름과 암호만으로 인증할 수 있기 때문에 더 편리하게 사용할 수 있다.

//////////////////////////
It has probably become the most popular way to use Git now, since it can be set up to both serve anonymously like the `git://` protocol, and can also be pushed over with authentication and encryption like the SSH protocol.
Instead of having to set up different URLs for these things, you can now use a single URL for both.
If you try to push and the repository requires authentication (which it normally should), the server can prompt for a username and password.
The same goes for read access.
//////////////////////////
아마 지금은 Git에서 가장 많이 사용하는 프로토콜일 것이다. `git://` 프로토콜처럼 익명으로 사용할 수도 있고, SSH처럼 인증을 거쳐 Push 할 수도 있기 때문이다.
이 두 가지 동작을 다른 URL로 나눌 필요없이 하나의 URL로 통합해서 사용할 수 있다.
그냥 인증기능을 켜놓은 저장소에 Push를 하면 서버는 사용자이름과 암호를 물어본다. 그리고 Fetch나 Pull 같은 읽기 작업에서도 같은 URL을 사용한다.

//////////////////////////
In fact, for services like GitHub, the URL you use to view the repository online (for example, https://github.com/schacon/simplegit[]) is the same URL you can use to clone and, if you have access, push over.
//////////////////////////
실제로 GitHub 같은 서비스에서 제공하는 저장소는 Clone을 할 때나 Push를 할 때 같은 URL을 사용한다. (예, https://github.com/schacon/simplegit[])

//////////////////////////
===== Dumb HTTP
//////////////////////////
===== 멍청한 HTTP

(((protocols, dumb HTTP)))
//////////////////////////
If the server does not respond with a Git HTTP smart service, the Git client will try to fall back to the simpler _Dumb_ HTTP protocol.
The Dumb protocol expects the bare Git repository to be served like normal files from the web server.
The beauty of Dumb HTTP is the simplicity of setting it up.
Basically, all you have to do is put a bare Git repository under your HTTP document root and set up a specific `post-update` hook, and you're done (See <<ch08-customizing-git#_git_hooks>>).
At that point, anyone who can access the web server under which you put the repository can also clone your repository.
To allow read access to your repository over HTTP, do something like this:
//////////////////////////
Git 서버가 스마트 HTTP 요청에 응답하지 않으면 Git 클라이언트는 차선책으로 _멍청한_ HTTP 프로토콜을 시도한다.
이 멍청한 프로토콜은 원격 저장소를 그냥 파일 건네주는 웹 서버로 취급한다.
HTTP와 HTTPS 프로토콜은 아름다울 정도로 설정이 간단하다.
HTTP 도큐먼트 루트 밑에 Bare 저장소를 두고 `post-update` 훅을 설정하는 것이 기본적으로 해야 하는 일의 전부다(<<ch08-customizing-git#_git_hooks>> 에서 자세히 다룰 것이다).
저장소가 있는 웹 서버에 접근할 수 있다면 그 저장소를 Clone 할 수도 있다.
아래와 같이 HTTP를 통해서 저장소를 읽을 수 있게 한다.

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

//////////////////////////
That's all.(((hooks, post-update)))
The `post-update` hook that comes with Git by default runs the appropriate command (`git update-server-info`) to make HTTP fetching and cloning work properly.
This command is run when you push to this repository (over SSH perhaps); then, other people can clone via something like
//////////////////////////
다 됐다.(((hooks, post-update)))
`post-update` 훅은 Git에 포함되어 있으며 `git update-server-info` 라는 명령어를 실행시킨다. 이 명령어를 써야 HTTP로 Fetch와 Clone 명령이 제대로 동작한다.
누군가 SSH를 통해서 저장소에 Push 하면 `post-update` 훅이 실행된다. 그럼 다른 사용자들은 Push 된 파일을 아래와 같이 Clone 할 수 있다.

[source,console]
----
$ git clone https://example.com/gitproject.git
----

//////////////////////////
In this particular case, we're using the `/var/www/htdocs` path that is common for Apache setups, but you can use any static web server -- just put the bare repository in its path.
The Git data is served as basic static files (see the <<ch10-git-internals#ch10-git-internals>> chapter for details about exactly how it's served).
//////////////////////////
여기서는 Apache 서버를 사용해서 기본 루트 디렉토리인 `/var/www/htdocs` 를 사용하지만 다른 웹 서버를 사용해도 된다. 단순히 Bare 저장소를 HTTP 문서 루트에 넣으면 된다.
Git 데이터는 일반적인 정적 파일처럼 취급된다(<<ch10-git-internals#ch10-git-internals>> 에서 정확히 어떻게 처리하는지 다룬다).

//////////////////////////
Generally you would either choose to run a read/write Smart HTTP server or simply have the files accessible as read-only in the Dumb manner.
It's rare to run a mix of the two services.
//////////////////////////
보통은 스마트 HTTP 프로토콜만 이용하거나 멍청한 HTTP 프로토콜만 사용한다.
이 둘을 한꺼번에 사용하는 경우는 드물다.

//////////////////////////
===== The Pros
//////////////////////////
===== 장점

//////////////////////////
We'll concentrate on the pros of the Smart version of the HTTP protocol.
//////////////////////////
스마트 HTTP 프로토콜의 장점만 보자

//////////////////////////
The simplicity of having a single URL for all types of access and having the server prompt only when authentication is needed makes things very easy for the end user.
Being able to authenticate with a username and password is also a big advantage over SSH, since users don't have to generate SSH keys locally and upload their public key to the server before being able to interact with it.
For less sophisticated users, or users on systems where SSH is less common, this is a major advantage in usability.
It is also a very fast and efficient protocol, similar to the SSH one.
//////////////////////////
읽기와 쓰기에 하나의 URL만 사용한다. 그리고 사용자에게 익숙한 사용자이름과 암호 방식의 인증을 사용한다.
사용자이름과 암호 방식의 인증이 SSH에 비해 사용하기 간단하다. SSH는 사용자가 알아서 키를 만들고 공개키를 서버에 올린 후에야 비로소 인증을 받을 수 있다.
SSH에 대해 잘 모르거나 익숙지 않은 사용자를 생각하면 이런 사용성은 엄청난 장점이다.
게다가 SSH만큼이나 빠르고 효율적이기 까지 하다.

//////////////////////////
You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates.
//////////////////////////
HTTPS를 이용해서 전송하는 데이터를 암호화하는 것도, 클라이언트에게 서명된 SSL 인증서를 요구하는 것도 가능하다.

//////////////////////////
Another nice thing is that HTTPS are such commonly used protocols that corporate firewalls are often set up to allow traffic through these ports.
//////////////////////////
HTTPS는 매우 보편적인 프로토콜이기 때문에 거의 모든 회사 방화벽에서 통과하도록 돼있다는 장점도 있다.

//////////////////////////
===== The Cons
//////////////////////////
===== 단점

//////////////////////////
Git over HTTPS can be a little more tricky to set up compared to SSH on some servers.
Other than that, there is very little advantage that other protocols have over Smart HTTP for serving Git content.
//////////////////////////
HTTPS를 사용하도록 설정하는 것이 SSH로 설정하는 것보다 까다로운 서버가 있다.
그것 말고는 스마트 HTTP 프로토콜이 다른 프로토콜보다 못한 단점은 별로 없다.

//////////////////////////
If you're using HTTP for authenticated pushing, providing your credentials is sometimes more complicated than using keys over SSH.
There are, however, several credential caching tools you can use, including Keychain access on macOS and Credential Manager on Windows, to make this pretty painless.
Read <<ch07-git-tools#_credential_caching>> to see how to set up secure HTTP password caching on your system.
//////////////////////////
Push 할 때 HTTP 인증을 사용하면 SSH 인증키를 사용하는 것보다 좀 더 복잡하다.
그래도 인증 캐싱 툴을 사용하면 좀 낫다. OSX에는 키체인(Keychain Access)이, Windows에는 인증서 관리자(Credential Manager)가 있다.
HTTP 암호 캐싱 설정에 대한 더 자세한 사항은 <<ch07-git-tools#_credential_caching>> 를 참고하길 바란다.

//////////////////////////
==== The SSH Protocol
//////////////////////////
==== SSH 프로토콜

(((protocols, SSH)))
//////////////////////////
A common transport protocol for Git when self-hosting is over SSH.
This is because SSH access to servers is already set up in most places -- and if it isn't, it's easy to do.
SSH is also an authenticated network protocol and, because it's ubiquitous, it's generally easy to set up and use.
//////////////////////////
Git의 대표 프로토콜은 SSH이다. SSH를 이용하면 아무런 외부 도구 없이 Git 서버를 구축할 수 있다.
대부분 서버는 SSH로 접근할 수 있도록 설정돼 있다. 뭐, 설정돼 있지 않더라도 쉽게 설정할 수 있다.
그리고 SSH는 인증 기능이 있고 어디에서든 사용할 수 있으며 사용하기도 쉽다.

//////////////////////////
To clone a Git repository over SSH, you can specify an `ssh://` URL like this:
//////////////////////////
SSH를 통해 Git 저장소를 Clone 하려면 `ssh://` 로 시작하는 URL을 사용한다:

[source,console]
----
$ git clone ssh://[user@]server/project.git
----

//////////////////////////
Or you can use the shorter scp-like syntax for the SSH protocol:
//////////////////////////
아래와 같은 SCP 형태의 구문으로 줄여 쓸 수도 있다.

[source,console]
----
$ git clone [user@]server:project.git
----

//////////////////////////
In both cases above, if you don't specify the optional username, Git assumes the user you're currently logged in as.
//////////////////////////
사용자 계정을 생략할 수도 있는데 계정을 생략하면 Git은 현재 로그인한 사용자의 계정을 사용한다.

//////////////////////////
===== The Pros
//////////////////////////
===== 장점

//////////////////////////
The pros of using SSH are many.
First, SSH is relatively easy to set up -- SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them.
Next, access over SSH is secure -- all data transfer is encrypted and authenticated.
Last, like the HTTPS, Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.
//////////////////////////
SSH 장점은 정말 많다.
첫째, SSH는 상대적으로 설정하기 쉽다. SSH 데몬은 정말 흔하다. 많은 네트워크 관리자들은 SSH 데몬을 다루어 본 경험이 있고 대부분의 OS 배포판에는 SSH 데몬과 관리도구들이 모두 들어 있다.
둘째, SSH를 통해 접근하면 보안에 안전하다. 모든 데이터는 암호화되어 인증된 상태로 전송된다.
마지막으로 SSH는 HTTPS, Local 프로토콜과 마찬가지로 전송 시 데이터를 가능한 압축하기 때문에 효율적이다.

//////////////////////////
===== The Cons
//////////////////////////
===== 단점

//////////////////////////
The negative aspect of SSH is that it doesn't support anonymous access to your Git repository.
If you're using SSH, people _must_ have SSH access to your machine, even in a read-only capacity, which doesn't make SSH conducive to open source projects for which people might simply want to clone your repository to examine it.
If you're using it only within your corporate network, SSH may be the only protocol you need to deal with.
If you want to allow anonymous read-only access to your projects and also want to use SSH, you’ll have to set up SSH for you to push over but something else for others to fetch from.
//////////////////////////
SSH는 익명으로 접근할 수 없다.
심지어 읽기 전용인 경우에도 익명으로 시스템에 접근할 수 없다.
회사에서만 사용할 거라면 SSH가 가장 적합한 프로토콜일 것이지만 오픈소스 프로젝트는 SSH만으로는 부족하다.
만약 SSH를 사용하는 프로젝트에 익명으로 접근할 수 있게 하려면, Push 할 때는 SSH로 하고 다른 사람들이 Fetch 할 때는 다른 프로토콜을 사용하도록 설정해야 한다.

//////////////////////////
==== The Git Protocol
//////////////////////////
==== Git 프로토콜

(((protocols, git)))
//////////////////////////
Next is the Git protocol.
This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.
In order for a repository to be served over the Git protocol, you must create a `git-daemon-export-ok` file -- the daemon won't serve a repository without that file in it -- but other than that there is no security.
Either the Git repository is available for everyone to clone, or it isn't.
This means that there is generally no pushing over this protocol.
You can enable push access but, given the lack of authentication, anyone on the internet who finds your project's URL could push to that project.
Suffice it to say that this is rare.
//////////////////////////
Git 프로토콜은 Git에 포함된 데몬을 사용하는 것이다.
포트는 9418이며 SSH 프로토콜과 비슷한 서비스를 제공하지만, 인증 메커니즘이 없다.
저장소에 git-export-daemon-ok 파일을 만들면 Git 프로토콜로 서비스할 수 있지만, 보안은 없다. 이 파일이 없는 저장소는 서비스되지 않는다.
이 저장소는 누구나 Clone 할 수 있거나 아무도 Clone 할 수 없거나 둘 중의 하나만 선택할 수 있다.
그래서 이 프로토콜로는 Push 하게 할 수 없다.
엄밀히 말하자면 Push 할 수 있도록 설정할 수 있지만, 인증하도록 할 수 없다. 그러니까 당신이 Push 할 수 있으면 이 프로젝트의 URL을 아는 사람은 누구나 Push 할 수 있다.
그냥 이런 것도 있지만 잘 안 쓴다고 알고 있으면 된다.

//////////////////////////
===== The Pros
//////////////////////////
===== 장점

//////////////////////////
The Git protocol is often the fastest network transfer protocol available.
If you’re serving a lot of traffic for a public project or serving a very large project that doesn't require user authentication for read access, it’s likely that you'll want to set up a Git daemon to serve your project.
It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.
//////////////////////////
Git 프로토콜은 전송 속도가 가장 빠르다고 할 수 있다.
전송량이 많은 공개 프로젝트나 별도의 인증이 필요 없고 읽기만 허용하는 프로젝트를 서비스할 때 유용하다.
암호화와 인증을 빼면 SSH 프로토콜과 전송 메커니즘이 별반 다르지 않다.

//////////////////////////
===== The Cons
//////////////////////////
===== 단점

//////////////////////////
The downside of the Git protocol is the lack of authentication.
It's generally undesirable for the Git protocol to be the only access to your project.
Generally, you'll pair it with SSH or HTTPS access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.
It's also probably the most difficult protocol to set up.
It must run its own daemon, which requires `xinetd` configuration or the like, which isn't always a walk in the park.
It also requires firewall access to port 9418, which isn't a standard port that corporate firewalls always allow.
Behind big corporate firewalls, this obscure port is commonly blocked.
//////////////////////////
Git 프로토콜의 단점은 인증 메커니즘이 없다는 것이다.
Git 프로토콜만으로 접근할 수 있는 프로젝트는 바람직하지 못하다.
일반적으로 SSH나 HTTPS 프로토콜과 함께 사용한다. 소수의 개발자만 Push 할 수 있고 대다수 사람은 `git://` 을 사용하여 읽을 수만 있게 하는 것이다.
어쩌면 가장 설치하기 어려운 방법일 수도 있다.
별도의 데몬이 필요하고 프로젝트에 맞게 설정해야 한다.
자원을 아낄 수 있도록 xinetd 같은 것도 설정해야 하고 방화벽을 통과할 수 있도록 9418 포트도 열어야 한다.
이 포트는 일반적으로 회사들이 허용하는 표준 포트가 아니다.
규모가 큰 회사의 방화벽이라면 당연히 이 포트를 막아 놓는다.
