[[_git_reset]]
//////////////////////////
=== Reset Demystified
//////////////////////////
=== Reset 명확히 알고 가기

//////////////////////////
Before moving on to more specialized tools, let's talk about `reset` and `checkout`.
These commands are two of the most confusing parts of Git when you first encounter them.
They do so many things, that it seems hopeless to actually understand them and employ them properly.
For this, we recommend a simple metaphor.
//////////////////////////
다른 도구들을 더 보기전에 `reset`과 `checkout`에 대해 이야기를 해보자.
이 두 명령어는 Git을 처음 사용하는 사람들이 가장 헷갈리는 부분이다.
제대로 이해하고 사용할 수 없을것 같아 보일 정도로 많은 기능을 지녔다.
이걸 이해하기 위해서 먼저 단순한 메타포를 제안하겠다.

//////////////////////////
==== The Three Trees
//////////////////////////
==== 세 개의 트리

//////////////////////////
An easier way to think about `reset` and `checkout` is through the mental frame of Git being a content manager of three different trees.
By ``tree'' here we really mean ``collection of files'', not specifically the data structure.
(There are a few cases where the index doesn't exactly act like a tree, but for our purposes it is easier to think about it this way for now.)
//////////////////////////
Git을 서로 다른 세 개의 트리의 컨텐츠 관리자로 생각하면 `reset`와 `checkout`에 대해 좀 더 쉽게 다가갈 수 있다.
여기서 ``트리''는 실제로는 ``파일의 묶음''이다. 자료구조로써의 트리가 아니다.
(인덱스는 어떤 특이한 경우에 트리처럼 동작하지 않지만 당장에 이해를 쉽게 하기 위해 일단 트리라고 하자)

//////////////////////////
Git as a system manages and manipulates three trees in its normal operation:
//////////////////////////
Git은 일반적으로 세 가지 트리를 관리하는 시스템이다.

[cols="1,2",options="header"]
|================================
//////////////////////////
| Tree              | Role
| HEAD              | Last commit snapshot, next parent
| Index             | Proposed next commit snapshot
| Working Directory | Sandbox
//////////////////////////
| 트리             | 역할
| HEAD             | 마지막 커밋 스냅샷, 다음 부모
| 인덱스(Index)    | 다음 커밋할 스냅샷
| 워킹 디렉터리    | 샌드박스
|================================

//////////////////////////
===== The HEAD
//////////////////////////
===== HEAD

//////////////////////////
HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch.
That means HEAD will be the parent of the next commit that is created.
It's generally simplest to think of HEAD as the snapshot of *your last commit*.
//////////////////////////
HEAD는 현재 브랜치의 가장 마지막 커밋을 가리키는 포인터이다. // TODO
즉 지금의 HEAD는 바로 다음에 할 커밋의 부모가 된다는 말이다.
단순하게 HEAD를 *마지막 커밋의 스냅샷*으로 생각하자.

//////////////////////////
In fact, it's pretty easy to see what that snapshot looks like.
Here is an example of getting the actual directory listing and SHA checksums for each file in the HEAD snapshot:
//////////////////////////
실제로 스냅샷으로 보는게 꽤 편하다.
아래에 예제가 있다. 여기서 HEAD 스냅샷에서의 파일의 SHA 체크섬을 확인해보자.


[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

//////////////////////////
The `cat-file` and `ls-tree` commands are ``plumbing'' commands that are used for lower level things and not really used in day-to-day work, but they help us see what's going on here.
//////////////////////////
`cat-file`와 `ls-tree`는 실제 업무에서는 잘 사용되지않는 저수준 명령어이다. ``plumbing''명령어라고 한다. 하지만 여기서는 무슨 일이 일어나는지 보기위해 사용한다.

[[_the_index]]
//////////////////////////
===== The Index
//////////////////////////
===== 인덱스

//////////////////////////
The Index is your *proposed next commit*. We've also been referring to this concept as Git's ``Staging Area'' as this is what Git looks at when you run `git commit`.
//////////////////////////
인덱스는 *바로 다음에 커밋할* 것들이다. 이미 앞에서 우리는 이런 개념을 ``Stagin Area''라고 배운바 있다. ``Staging Area''는 사용자가 `git commit` 명령을 실행했을 때 Git이 처리할 것들이 있는 곳이다.

Git populates this index with a list of all the file contents that were last checked out into your working directory and what they looked like when they were originally checked out.
You then replace some of those files with new versions of them, and `git commit` converts that into the tree for a new commit.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Again, here we're using `ls-files`, which is more of a behind the scenes command that shows you what your index currently looks like.

The index is not technically a tree structure – it's actually implemented as a flattened manifest – but for our purposes it's close enough.

//////////////////////////
===== The Working Directory
//////////////////////////
===== 워킹 디렉터리

//////////////////////////
Finally, you have your working directory.
The other two trees store their content in an efficient but inconvenient manner, inside the `.git` folder.
The Working Directory unpacks them into actual files, which makes it much easier for you to edit them.
Think of the Working Directory as a *sandbox*, where you can try changes out before committing them to your staging area (index) and then to history.
//////////////////////////
마지막으로 워킹 디렉터리를 보자.
위의 두 트리는 효율적이지만 알아보기에 힘든 형태로 `.git`디렉터리에 저장되어있다.
워킹 디렉터리는 실제 파일로 존재한다. 그래서 사용자가 편집하기에 수월하다.
워킹 디렉터리는 *샌드박스*로 생각하자. 인덱스에 올려놓고 커밋하기 전에는 얼마든지 변경할 수 있다.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

//////////////////////////
==== The Workflow
//////////////////////////
==== Workflow

//////////////////////////
Git's main purpose is to record snapshots of your project in successively better states, by manipulating these three trees.
//////////////////////////
Git은 점점 더 발전해가는 프로젝트의 스냅샷을 세 가지 트리를 사용해 기록하는 것이 주 임무이다.

image::images/reset-workflow.png[]

//////////////////////////
Let's visualize this process: say you go into a new directory with a single file in it.
We'll call this *v1* of the file, and we'll indicate it in blue.
Now we run `git init`, which will create a Git repository with a HEAD reference which points to an unborn branch (`master` doesn't exist yet).
//////////////////////////
이 과정을 시각화해보자. 하나의 파일이 있는 디렉터리로 이동한다.
이걸 파일의 *v1*이라고 하고 파란색으로 표시한다.
`git init`을 실행하면 Git 저장소가 생기고 HEAD가 아직 생기지 않은 브랜치를 가리치게 된다.(`master`는 아직 존재하지 않는다.)

image::images/reset-ex1.png[]

//////////////////////////
At this point, only the Working Directory tree has any content.
//////////////////////////
이 시점에서는 워킹 디렉터리 트리만 데이터를 가진다.

//////////////////////////
Now we want to commit this file, so we use `git add` to take content in the Working Directory and copy it to the Index.
//////////////////////////
이제 파일을 커밋하자. `git add`는 워킹 디렉터리의 내용을 인덱스로 복사한다.

image::images/reset-ex2.png[]

//////////////////////////
Then we run `git commit`, which takes the contents of the Index and saves it as a permanent snapshot, creates a commit object which points to that snapshot, and updates `master` to point to that commit.
//////////////////////////
그리고 `git commit`을 실행한다. 그러면 인덱스의 내용이 스냅샷으로 영구히 저장되고 그 스냅샷을 가리키는 커밋 객체를 만든다. 그리고는 `master`가 이 커밋 객체를 가리키도록한다.

image::images/reset-ex3.png[]

If we run `git status`, we'll see no changes, because all three trees are the same.
//////////////////////////
`git status`를 실행하면 변경 사항이 없다고 나온다. 세 트리 모두가 같기 때문이다.
//////////////////////////

//////////////////////////
Now we want to make a change to that file and commit it.
We'll go through the same process; first we change the file in our working directory.
Let's call this *v2* of the file, and indicate it in red.
//////////////////////////
파일을 바꾸고 커밋을 해보자.
먼저 워킹 디렉터리의 파일을 고친다.
이걸 그 파일의 *v2*라고 하자. 이건 빨간색으로 표시한다.

image::images/reset-ex4.png[]

//////////////////////////
If we run `git status` right now, we'll see the file in red as ``Changes not staged for commit,'' because that entry differs between the Index and the Working Directory.
Next we run `git add` on it to stage it into our Index.
//////////////////////////
`git status`를 바로 실행하면 ``Changes not staged for commit,'' 아래에 빨간색으로 된 파일을 볼 수 있다. 인덱스와 워킹 디렉터리가 다른 내용을 담고 있기 때문에 그렇다.
`git add`를 실행해서 변경 사항을 인덱스에 올려주자.

image::images/reset-ex5.png[]

//////////////////////////
At this point if we run `git status` we will see the file in green
under ``Changes to be committed'' because the Index and HEAD differ – that is, our proposed next commit is now different from our last commit.
Finally, we run `git commit` to finalize the commit.
//////////////////////////
이 시점에서 `git status`를 쳐보면 ``Changes to be committed'' 아래에 파일 이름이 녹색으로 변했다.
인덱스와 HEAD가 다르기 때문이다. 즉, 다음 커밋 내용과 지금 마지막 커밋의 내용이 다르다는 말이다.
마지막으로 `git commit`을 실행해 커밋한다.

image::images/reset-ex6.png[]

//////////////////////////
Now `git status` will give us no output, because all three trees are the same again.
//////////////////////////
이제 `git status`를 실행하면 아무런 출력을 하지 않는다. 세 개의 트리가 다시 같은 내용을 담고있기 때문이다.

//////////////////////////
Switching branches or cloning goes through a similar process.
When you checkout a branch, it changes *HEAD* to point to the new branch ref, populates your *Index* with the snapshot of that commit, then copies the contents of the *Index* into your *Working Directory*.
//////////////////////////
브랜치를 바꾸거나 클론도 비슷한 절차를 밟는다.
브랜치를 체크아웃하면, *HEAD*가 새로운 브랜치를 가리키도록 바뀌고, 새로운 커밋의 스냅샷을 *인덱스*에 놓는다. 그리고 인덱스의 내용을 *워킹 디렉터리*로 복사한다.

//////////////////////////
==== The Role of Reset
//////////////////////////
==== Reset의 역할

//////////////////////////
The `reset` command makes more sense when viewed in this context.
//////////////////////////
`reset` 명령어는 이런 맥락에서 볼 때 더 의미있다.

//////////////////////////
For the purposes of these examples, let's say that we've modified `file.txt` again and committed it a third time. So now our history looks like this:
//////////////////////////
예제를 보자. `file.txt`를 수정하고 커밋하기를 세 번 반복했다. 그러면 히스토리는 다음과 같이 나온다.

image::images/reset-start.png[]

//////////////////////////
Let's now walk through exactly what `reset` does when you call it. It directly manipulates these three trees in a simple and predictable way.
It does up to three basic operations.
//////////////////////////
자 이제 `reset`이 어떤 일을 하는지 낱낱이 파헤쳐보자. `reset`은 이 세 개의 트리를 간단하고 예측가능한 방법으로 조작한다.
세 가지 기본 작업이다. //TODO

//////////////////////////
===== Step 1: Move HEAD
//////////////////////////
===== Step 1: HEAD 이동시키기

//////////////////////////
The first thing `reset` will do is move what HEAD points to.
This isn't the same as changing HEAD itself (which is what `checkout` does); `reset` moves the branch that HEAD is pointing to.
This means if HEAD is set to the `master` branch (ie, you're currently on the `master` branch), running `git reset 9e5e64a` will start by making `master` point to `9e5e64a`.
//////////////////////////
먼저 `reset`은 HEAD를 이동시킨다.
이건 `checkout`처럼 HEAD 자체를 바꾸는게 아니다. HEAD가 가리키는 브랜치를 이동시키는 것이다.
HEAD가 `master` 브랜치를 가리키고 있다면(현재 `master`브랜치에 있다면) `git reset 9e5e64a`를 실행한 후에 `master`는 `9e5e64a`를 가리킨다. 

image::images/reset-soft.png[]

//////////////////////////
No matter what form of `reset` with a commit you invoke, this is the first thing it will always try to do.
With `reset --soft`, it will simply stop there.
//////////////////////////
커밋을 뒤에 달고 사용하는 `reset`은 어떤 형태든 상관없이 언제나 이 작업을 수행한다.
`reset --soft`를 수행하면 여기에서 동작을 멈춘다.

//////////////////////////
Now take a second to look at that diagram and realize what happened: it essentially undid the last `git commit` command.
When you run `git commit`, Git creates a new commit and moves the branch that HEAD points to up to it.
When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
You could now update the Index and run `git commit` again to accomplish what `git commit --amend` would have done (see <<_git_amend>>).
//////////////////////////
두 번째를 다이어그램을 보고 무엇이 일어날지 생각해보자. 가장 최근의 `git commit`명령어를 되돌린다.
`git commit`을 실행하면 Git은 새로운 커밋을 생성하고 HEAD가 가리키고 있는 브랜치를 새로운 커밋으로 이동시킨다.
`reset`뒤에 `HEAD~`(HEAD의 부모 커밋)를 주면 인덱스나 워킹 디렉터리는 그대로 놔두고 브랜치만 이전으로 되돌린다.
인덱스를 업데이트한 다음에 `git commit`를 실행하면 `git commit --amend`와 같다.(<<_git_amend>>를 참조)

//////////////////////////
===== Step 2: Updating the Index (--mixed)
//////////////////////////
===== Step 2: 인덱스 갱신 (--mixed)

//////////////////////////
Note that if you run `git status` now you'll see in green the difference between the Index and what the new HEAD is.
//////////////////////////
이제 `git status`를 실행하면 인덱스와 새로운 HEAD의 다른 점이 녹색으로 쓰여있는 것을 볼 수 있다.

//////////////////////////
The next thing `reset` will do is to update the Index with the contents of whatever snapshot HEAD now points to.
//////////////////////////
이번에 배울 `reset`의 기능은 현재 HEAD가 가리키는 스크린샷의 내용으로 인덱스를 업데이트 하는것이다.

image::images/reset-mixed.png[]

//////////////////////////
If you specify the `--mixed` option, `reset` will stop at this point.
//////////////////////////
`--mixed`옵션 주어 실행하면 이 단계에서 멈춘다.

//////////////////////////
This is also the default, so if you specify no option at all (just `git reset HEAD~` in this case), this is where the command will stop.
//////////////////////////
아무 옵션을 사용하지 않으면 이 옵션으로 동작한다. (이 예제의 경우에는 `git reset HEAD~`와 같다)

//////////////////////////
Now take another second to look at that diagram and realize what happened: it still undid your last `commit`, but also _unstaged_ everything.
You rolled back to before you ran all your `git add` and `git commit` commands.
//////////////////////////
그림을 보고 어떻게 동작하는지 알아보자. 여전히 마지막 `커밋`을 되돌린다. 그리고 _stage에서도 없앤다._
`git add`하고 `git commit`을 하기 전으로 되돌리는 것이다.

//////////////////////////
===== Step 3: Updating the Working Directory (--hard)
//////////////////////////
===== Step 3: 워킹 디렉터리 갱신 (--hard)

//////////////////////////
The third thing that `reset` will do is to make the Working Directory look like the Index.
If you use the `--hard` option, it will continue to this stage.
//////////////////////////
`reset`이 세 번째로 하는 것은 워킹 디렉터리도 인덱스처럼 수정하는 것이다.
`--hard`옵션을 사용하면 이 단계까지 수행한다.

image::images/reset-hard.png[]

//////////////////////////
So let's think about what just happened.
You undid your last commit, the `git add` and `git commit` commands, **and** all the work you did in your working directory.
//////////////////////////
어떻게 동작하는지 알아보자.
`git add`와 `git commit`명령어로 만들어진 마지막 커밋을 되돌린다. **그리고** 워킹 디렉터리의 내용도 되돌린다.

//////////////////////////
It's important to note that this flag (`--hard`) is the only way to make the `reset` command dangerous, and one of the very few cases where Git will actually destroy data.
Any other invocation of `reset` can be pretty easily undone, but the `--hard` option cannot, since it forcibly overwrites files in the Working Directory.
In this particular case, we still have the *v3* version of our file in a commit in our Git DB, and we could get it back by looking at our `reflog`, but if we had not committed it, Git still would have overwritten the file and it would be unrecoverable.
//////////////////////////
이 옵션(`--hard`)은 매우 중요하다. `reset`을 위험인자로 만드는 유일한 옵션이다. Git으로 데이터를 실제로 삭제하는 정말 얼마 안되는 방법중 하나이기 때문이다.
`reset`을 어떻게 사용하더라도 꽤 간단히 작업 결과를 되돌릴 수 있다. 하지만 `--hard`옵션은 불가능하다. 이 옵션을 사용하면 워킹 디렉터리의 파일들을 강제로 덮어쓴다.
이 예제의 경우에는 파일의 *v3*버전을 아직 Git이 커밋으로 보관하고 있다. `reflog`를 이용해서 다시 복원할 수 있다. 하지만 커밋하지 않은 데이터는 복원이 불가능하다.

//////////////////////////
===== Recap
//////////////////////////
===== 복습

//////////////////////////
The `reset` command overwrites these three trees in a specific order, stopping when you tell it to:
//////////////////////////
`reset` 명령어는 정해진 순서대로 세 개의 트리를 덮어써나가다가 옵션에 따라 지정한 곳에서 멈춘다.

//////////////////////////
1. Move the branch HEAD points to _(stop here if `--soft`)_
2. Make the Index look like HEAD _(stop here unless `--hard`)_
3. Make the Working Directory look like the Index
//////////////////////////
1. HEAD를 옮긴다._(`--soft` 옵션이 붙으면 이 단계에서 멈춘다.)_
2. 인덱스를 HEAD의 상태로 만든다. _(`--hard` 옵션이 붙지 않았으면 이 단계에서 멈춘다.)_
3. 워킹 디렉터리를 인덱스의 상태로 만든다.

//////////////////////////
==== Reset With a Path
//////////////////////////
==== 경로를 주어 Reset하기

//////////////////////////
That covers the behavior of `reset` in its basic form, but you can also provide it with a path to act upon.
If you specify a path, `reset` will skip step 1, and limit the remainder of its actions to a specific file or set of files.
This actually sort of makes sense – HEAD is just a pointer, and you can't point to part of one commit and part of another.
But the Index and Working directory _can_ be partially updated, so reset proceeds with steps 2 and 3.
//////////////////////////
`reset`의 
경로를 지정하면 1단계를 건너뛰고 정해진 경로의 파일들에만 `reset`을 적용한다.
이는 당연한 이야기다. HEAD는 포인터인데, 커밋의 일부분만 가리키는 것은 못한다.
하지만 인덱스나 워킹 디렉터리는 일부분만 갱신할 수 있다. 따라서 reset는 2, 3단계만 수행한다.

//////////////////////////
So, assume we run `git reset file.txt`.
This form (since you did not specify a commit SHA or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:
//////////////////////////
`git reset file.txt`를 실행하다고 가정하자.
이 형식은(커밋의 해시값이나 브랜치도 표기하지 않고 `--soft`나 `--hard`도 표기하지 않았다) `git reset --mixed HEAD file.txt`를 짧게 쓴 것이다.

//////////////////////////
1. Move the branch HEAD points to _(skipped)_
2. Make the Index look like HEAD _(stop here)_
//////////////////////////
1. HEAD브랜치를 옮긴다 _(건너뜀)_
2. 인덱스를 HEAD와 같은 상태로 만든다. _(여기서 멈춤)_

//////////////////////////
So it essentially just copies `file.txt` from HEAD to the Index.
//////////////////////////
본질적으로는 `file.txt`를 HEAD에서 인덱스로 복사하는 것과 같다.

image::images/reset-path1.png[]

//////////////////////////
This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.
//////////////////////////
파일을 State에서 내리는 것과 동일하다.
이 명령어와 `git add`의 동작을 다이어그램으로 그리면 그 둘이 정확히 반대되는 동작을 한다는걸 알 수 있다.

image::images/reset-path2.png[]

//////////////////////////
This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<_unstaging>> for more on this.)
//////////////////////////
이게 `git status`를 실행했을 때 Stage에서 파일을 내리려면 이 명령어를 치라고 나오는 이유이다.
(더 자세한 것은 <<_unstaging>>를 참고한다.)

//////////////////////////
We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.
//////////////////////////
특정 커밋을 명시하면 Git은 ```HEAD에서 파일을 가져오는'' 것이 아니라 그 커밋에서 파일을 가져온다.
명령을 `git reset eb43bf file.txt`같이 써주면 된다.

image::images/reset-path3.png[]

//////////////////////////
This effectively does the same thing as if we had reverted the content of the file to *v1* in the Working Directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our Working Directory again.
//////////////////////////
그러면 워킹 디렉터리의 파일들을 *v1*으로 되돌리고 거기에 `git add` 실행한 다음 다시 *v3*로 되돌린 것과 같아진다.(실제로 이런 단계를 밟진 않았다)
여기서 `git commit`을 실행하면 *v1*으로 되돌린 파일 내용을 기록할 것이다. 물론 실제로 워킹 디렉터리를 뒤로 돌린건 아니다.

//////////////////////////
It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.
//////////////////////////
`git add`가 그랬듯이 `reset`도 `--patch` 옵션을 사용해서 stage에서 내용을 hunk별로 내릴 수 있다.
그런다음 선택적으로 stage에서 내리거나 되돌릴 수 있다.

//////////////////////////
==== Squashing
//////////////////////////
==== 합치기(Squash)

//////////////////////////
Let's look at how to do something interesting with this newfound power – squashing commits.
//////////////////////////
커밋을 합친다는게 어떤 것인지 알아보자.

//////////////////////////
Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)
//////////////////////////
여러 커밋들이 ``oops.''나 ``WIP'', ``forgot this file''같은 메시지만 담고 있다고 해보자.
이럴 때 `reset`을 이용해 그 커밋들을 하나의 커밋으로 합쳐서 남들에게 똑똑한 척 할 수 있다.
(다른 방식으로도 <<_squashing>>을 할 수 있다. 이 예제에서는 `reset`을 더 간단히 이용하는 것을 보여준다.)

//////////////////////////
Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.
//////////////////////////
이런 프로젝트가 있다고 생각해보자. 첫 번째 커밋은 파일 하나만 있고, 두 번째 커밋에는 기존 파일이 수정된 다음 새로운 파일이 추가되었다. 세 번째 커밋에는 첫 번째 파일이 다시 수정되어있다.
두 번째 커밋은 작업중에 생긴 것이었기 때문에 이를 합치고 싶다.

image::images/reset-squash-r1.png[]

//////////////////////////
You can run `git reset --soft HEAD~2` to move the HEAD branch back to an older commit (the first commit you want to keep):
//////////////////////////
`git reset --soft HEAD~2`를 실행하여 HEAD를 이전 커밋으로 되돌릴 수 있다.(첫 번째 커밋만 유지한다)

image::images/reset-squash-r2.png[]

//////////////////////////
And then simply run `git commit` again:
//////////////////////////
그리고 `git commit`을 실행하자.

image::images/reset-squash-r3.png[]

//////////////////////////
Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`. The commit with the v2 version of the file is no longer in the history.
//////////////////////////
이제 사람들에게 공개할만한 히스토리가 만들어졌다. `file-a.txt`이 있는 v1 커밋이 하나 있고, 두 번째 커밋에는 v3버전의 `file-a.txt`파일과 새로 추가된 `file-b.txt`파일이 있다. v2버전의 커밋은 더 이상 히스토리에 남아있지 않다.


//////////////////////////
==== Check It Out
//////////////////////////
==== Checkout 

//////////////////////////
Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.
//////////////////////////
`checkout`도 `reset`처럼 세 가지 트리를 조작한다. 파일 경로를 쓰느냐 안쓰느냐에 따라 동작이 조금 다르다.

//////////////////////////
===== Without Paths
//////////////////////////
===== Without Paths 경로를 주지 않았을 때

//////////////////////////
Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.
//////////////////////////
`git checkout [branch]`는 `git reset --hard [branch]`와 비슷하게 동작한다. 이 또한 세 개의 트리를 조작하지만 두 가지 다른 점이 있다.

//////////////////////////
First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that – it tries to do a trivial merge in the Working Directory, so all of the files you _haven't_ changed in  will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.
//////////////////////////
첫 번째로 `reset --hard`와는 다르게 `checkout`에서 워킹 디렉터리는 안전하다. 즉, 변경된 파일을 날려버리지 않는다는 것을 보장한다.
워킹 디렉터리에서 머지를 시도할 때에 변경하지 _않은_ 모든 파일을 업데이트하는 것 보단 더 영리한 동작이다.
반면 `reset --hard`는 전반적으로 확인없이 모든 것을 바꿔버린다.

//////////////////////////
The second important difference is how it updates HEAD.
Where `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.
//////////////////////////
두 번째 중요한 차이점은 HEAD를 업데이트 하는 방식이다.
`reset`은 HEAD가 가리키는 브랜치를 움직이지만, `checkout`은 HEAD 그 자체를 다른 브랜치로 옮긴다.

//////////////////////////
For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.
//////////////////////////
예를 들어 각각 다른 커밋을 가리키고 있는 `master`와 `develop`브랜치가 있고 현재 우리가 있는 곳은 `develop` 브랜치라고 해보자.(다시 말해 HEAD가 `develop`을 가리키고 있다)
`git reset master`를 실행하면 `develop`는 `master`와 같은 커밋을 가리키게 된다.
반면, `git checkout master`를 실행하면 `develop`은 그대로 있고 HEAD만 움직인다.
HEAD는 `master`를 가리키게 된다.

//////////////////////////
So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.
//////////////////////////
그래서 위 두 경우 모두 HEAD는 A커밋을 가리키게 되지만 어떻게 그렇게 되었느냐는 완전히 다르다.
`reset`은 HEAD가 가리키는 브랜치를 옮겼고, `checkout`은 HEAD자체를 옮겼다.

image::images/reset-checkout.png[]

//////////////////////////
===== With Paths
//////////////////////////
===== With Paths 경로를 주었을 때

//////////////////////////
The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) – it's not working-directory safe, and it does not move HEAD.
//////////////////////////
`checkout`을 실행할 때에 파일 경로를 줄 수도 있다. `reset`과 비슷하게 HEAD가 움직이지 않는다.
동작은 `git reset [branch] file`과 비슷하다. 인덱스의 내용이 해당 커밋 버전으로 변경될뿐만 아니라 워킹 디렉터리의 파일도 해당 커밋 버전으로 변경된다.
이거 완전히 `git reset --hard [branch] file`의 동작이랑 같다. 워킹 디렉터리가 안전하지도 않고 HEAD도 움직이지 않는다.

//////////////////////////
Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.
//////////////////////////
`git reset`이나 `git add`처럼 `checkout`또한 `--patch`옵션을 사용해서 파일의 일부분을 선택적으로 되돌릴 수 있다.

//////////////////////////
==== Summary
//////////////////////////
==== 요약

//////////////////////////
Hopefully now you understand and feel more comfortable with the `reset` command, but are probably still a little confused about how exactly it differs from `checkout` and could not possibly remember all the rules of the different invocations.
//////////////////////////
이제 `reset`명령어를 이해하고 좀 더 편하게 대할수 있게 되었길 바란다. 하지만 아마 아직도 `checkout`과 정확하게 무엇이 다른지 조금 혼란스럽고 사용법을 다 익히지 못했을 것이다.

//////////////////////////
Here's a cheat-sheet for which commands affect which trees.
The ``HEAD'' column reads ``REF'' if that command moves the reference (branch) that HEAD points to, and ``HEAD'' if it moves HEAD itself.
Pay especial attention to the 'WD Safe?' column – if it says *NO*, take a second to think before running that command.
//////////////////////////
그래서 어떤 명령어가 어떤 트리에 영향을 주는지에 대한 요약표를 준비했다.
명령어가 HEAD가 가리키는 브랜치를 움직인다면 ``HEAD'' 열에 ``REF''라고 적혀있고 HEAD자체가 움직인다면 ``HEAD''라고 적혀있다.
'WD Safe?' 열을 꼭 보자. 여기에 *NO*라고 적혀있다면 해당 명령어를 실행하기 전에 한번쯤 더 생각해보아야한다.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
