[[_revision_selection]]
//////////////////////////
=== Revision Selection
//////////////////////////
=== 리비전 조회하기

//////////////////////////
Git allows you to specify specific commits or a range of commits in several ways.
They aren’t necessarily obvious but are helpful to know.
//////////////////////////
리비전 하나를 조회할 수도 있고 범위를 주고 여러 개를 조회할 수도 있다.
거의 필요하진 않지만 알아두면 좋다.

//////////////////////////
==== Single Revisions
//////////////////////////
==== 리비전 하나 가리키기

//////////////////////////
You can obviously refer to a commit by the SHA-1 hash that it’s given, but there are more human-friendly ways to refer to commits as well.
This section outlines the various ways you can refer to a single commit.
//////////////////////////
SHA-1 해시값으로도 커밋을 외울 수 있지만 사람이 사용하기 좋은 방법이 있다.
이 절에서는 커밋을 표현하는 방법을 몇 가지 설명한다.

//////////////////////////
==== Short SHA-1
//////////////////////////
==== SHA-1 줄여 쓰기

//////////////////////////
Git is smart enough to figure out what commit you meant to type if you provide the first few characters, as long as your partial SHA-1 is at least four characters long and unambiguous – that is, only one object in the current repository begins with that partial SHA-1.
//////////////////////////
Git은 해시값의 앞 몇 글자만으로도 어떤 커밋인지 충분히 식별할 수 있다. 중복되지 않으면 해시값의 앞 4자만으로도 나타낼 수 있다. 즉 짧은 SHA-1 값이라고 해도 유일해야 한다.

//////////////////////////
For example, to see a specific commit, suppose you run a `git log` command and identify the commit where you added certain functionality:
//////////////////////////
먼저 `git log` 명령으로 어떤 커밋이 있는지 조회하는 예제를 보자.

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>


    added some blame and merge stuff
----

//////////////////////////
In this case, choose `1c002dd....` If you `git show` that commit, the following commands are equivalent (assuming the shorter versions are unambiguous):
//////////////////////////
`git show` 명령으로 `1c002dd....`로 시작하는 커밋을 조회할 수 있다. 다음 명령은 모두 같다(단 짧은 해시값이 다른 커밋과 중복되지 않다고 가정).

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

//////////////////////////
Git can figure out a short, unique abbreviation for your SHA-1 values.
If you pass `--abbrev-commit` to the `git log` command, the output will use shorter values but keep them unique; it defaults to using seven characters but makes them longer if necessary to keep the SHA-1 unambiguous:
//////////////////////////
`git log` 명령에 `--abbrev-commit`라는 옵션을 추가하면 짧고 중복되지 않는 해시값을 보여준다.기본으로 7자를 보여주고 해시값이 중복되는 경우 더 긴 해시값을 보여준다.

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

//////////////////////////
Generally, eight to ten characters are more than enough to be unique within a project.
//////////////////////////
보통은 8자에서 10자 내외로도 충분히 유일하게 커밋을 나타낼 수 있다.

//////////////////////////
As an example, the Linux kernel, which is a pretty large project with over 450k commits and 3.6 million objects, has no two objects whose SHA-1s overlap more than the first 11 characters.
//////////////////////////
꽤 큰 프로젝트인 Linux 커널의 경우에는 45만개 이상의 커밋, 360만개 이상의 오브젝트가 있다. Linux 커널 프로젝트는 해시값 11개만 사용해도 충돌이 없다.

[NOTE]
//////////////////////////
====
.A SHORT NOTE ABOUT SHA-1
//////////////////////////
====
.SHA-1 해시값에 대한 단상

//////////////////////////
A lot of people become concerned at some point that they will, by random happenstance, have two objects in their repository that hash to the same SHA-1 value.
What then?
//////////////////////////
Git을 쓰는 사람들은 가능성이 작긴 하지만 언젠가 SHA-1 값이 중복될까 봐 걱정한다.
정말 그렇게 되면 어떤 일이 벌어질까?

//////////////////////////
If you do happen to commit an object that hashes to the same SHA-1 value as a previous object in your repository, Git will see the previous object already in your Git database and assume it was already written.
If you try to check out that object again at some point, you’ll always get the data of the first object.
//////////////////////////
<<<<<<< HEAD
이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각한다. 그래서 해당 SHA-1 값의 커밋을 Checkout 하면 항상 처음 저장한 커밋만 Checkout 된다.
||||||| merged common ancestors
이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각한다. 그래서 해당 SHA-1 값의 커밋을 Checkout하면 항상 처음 저장한 커밋만 Checkout 된다.
=======
이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각한다.
그래서 해당 SHA-1 값의 커밋을 Checkout하면 항상 처음 저장한 커밋만 Checkout 된다.
>>>>>>> chapter 7: proofreading

//////////////////////////
However, you should be aware of how ridiculously unlikely this scenario is. The SHA-1 digest is 20 bytes or 160 bits. The number of randomly hashed objects needed to ensure a 50% probability of a single collision is about 2^80^
(the formula for determining collision probability is `p = (n(n-1)/2) * (1/2^160))`. 2^80^
is 1.2 x 10^24^
or 1 million billion billion. That’s 1,200 times the number of grains of sand on the earth.
//////////////////////////
그러나 해시값이 중복되는 일은 일어나기 어렵다. SHA-1 값의 크기는 20 바이트(160비트)이다. 해시값이 중복될 확률이 50%가 되는 데 필요한 개체의 수는 `2^80^`이다.
이 수는 1자 2000해('자'는 '경'의 '억'배 - `10^24^`, 충돌 확률을 구하는 공식은 `p=(n(n-1)/2) * (1/2^160)` )이다.
즉, 지구에 존재하는 모래알의 수에 1200을 곱한 수와 맞먹는다.

//////////////////////////
Here’s an example to give you an idea of what it would take to get a SHA-1 collision.
If all 6.5 billion humans on Earth were programming, and every second, each one was producing code that was the equivalent of the entire Linux kernel history (3.6 million Git objects) and pushing it into one enormous Git repository, it would take roughly 2 years until that repository contained enough objects to have a 50% probability of a single SHA-1 object collision.
A higher probability exists that every member of your programming team will be attacked and killed by wolves in unrelated incidents on the same night.
====
//////////////////////////
아직도 SHA-1 해시값이 중복될까 봐 걱정하는 사람들을 위해 좀 더 덧붙이겠다.
지구에서 약 6억5천만 명의 인구가 개발하고 각자 매초 Linux 커널 히스토리 전체와(360만 개) 맞먹는 개체를 쏟아 내고 바로 Push 한다고 가정하자. 이런 상황에서 해시값의 충돌 날 확률이 50%가 되기까지는 약 2년이 걸린다.
그냥 어느 날 동료가 한순간에 모두 늑대에게 물려 죽을 확률이 훨씬 더 높다.
====

[[_branch_references]]
//////////////////////////
==== Branch References
//////////////////////////
==== 브랜치로 가리키기

//////////////////////////
The most straightforward way to specify a commit requires that it have a branch reference pointed at it.
Then, you can use a branch name in any Git command that expects a commit object or SHA-1 value.
For instance, if you want to show the last commit object on a branch, the following commands are equivalent, assuming that the `topic1` branch points to `ca82a6d`:
//////////////////////////
브랜치를 사용하는 것이 커밋을 나타내는 가장 쉬운 방법이다.
커밋 개체나 SHA-1 값이 필요한 곳이면 브랜치 이름을 사용할 수 있다.
만약 `topic1` 브랜치의 최근 커밋을 보고 싶으면 아래와 같이 실행한다. `topic1` 브랜치가 `ca82a6d`를 가리키고 있기 때문에 두 명령의 결과는 같다.

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

//////////////////////////
If you want to see which specific SHA-1 a branch points to, or if you want to see what any of these examples boils down to in terms of SHA-1s, you can use a Git plumbing tool called `rev-parse`.
You can see <<_git_internals>> for more information about plumbing tools; basically, `rev-parse` exists for lower-level operations and isn’t designed to be used in day-to-day operations.
However, it can be helpful sometimes when you need to see what’s really going on.
Here you can run `rev-parse` on your branch.
//////////////////////////
브랜치가 가리키는 개체의 SHA-1 값에 대한 궁금증은 `rev-parse`이라는 Plumbing 도구가 해결해 준다.
<<_git_internals>>에서 이 뚫어뻥에 대해 시원하게 설명한다. 기본적으로 `rev-parse`은 저수준 명령이기 때문에 평소에는 전혀 필요하지 않다.
그래도 한번 사용해보고 어떤 결과가 나오는지 알아 두자.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[_git_reflog]]
//////////////////////////
==== RefLog Shortnames
//////////////////////////
==== RefLog로 가리키기

//////////////////////////
One of the things Git does in the background while you’re working away is keep a ``reflog'' – a log of where your HEAD and branch references have been for the last few months.
//////////////////////////
Git은 자동으로 브랜치와 HEAD가 지난 몇 달 동안에 가리켰었던 커밋을 모두 기록하는데 이 로그를 ``Reflog''라고 부른다.

//////////////////////////
You can see your reflog by using `git reflog`:
//////////////////////////
`git reflog`를 실행하면 Reflog를 볼 수 있다.

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

//////////////////////////
Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history.
And you can specify older commits with this data, as well.
If you want to see the fifth prior value of the HEAD of your repository, you can use the `@{n}` reference that you see in the reflog output:
//////////////////////////
Git은 브랜치가 가리키는 것이 달라질 때마다 그 정보를 임시 영역에 저장한다.
그래서 예전에 가리키던 것이 무엇인지 확인해 볼 수 있다.
`@{n}` 규칙을 사용하면 아래와 같이 HEAD가 5번 전에 가리켰던 것을 알 수 있다.

[source,console]
----
$ git show HEAD@{5}
----

//////////////////////////
You can also use this syntax to see where a branch was some specific amount of time ago.
For instance, to see where your `master` branch was yesterday, you can type
//////////////////////////
순서뿐 아니라 시간도 사용할 수 있다. 어제 날짜의 `master` 브랜치를 보고 싶으면 아래와 같이 한다.

[source,console]
----
$ git show master@{yesterday}
----

//////////////////////////
That shows you where the branch tip was yesterday.
This technique only works for data that’s still in your reflog, so you can’t use it to look for commits older than a few months.
//////////////////////////
이 명령은 어제 master 브랜치가 가리키고 있던 것이 무엇인지 보여준다. Reflog에 남아있을 때에만 조회할 수 있기 때문에 너무 오래된 커밋은 조회할 수 없다.

//////////////////////////
To see reflog information formatted like the `git log` output, you can run `git log -g`:
//////////////////////////
`git log -g` 명령을 사용하면 `git reflog` 결과를 `git log` 명령과 같은 형태로 볼 수 있다.

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

//////////////////////////
It’s important to note that the reflog information is strictly local – it’s a log of what you’ve done in your repository.
The references won’t be the same on someone else’s copy of the repository; and right after you initially clone a repository, you'll have an empty reflog, as no activity has occurred yet in your repository.
Running `git show HEAD@{2.months.ago}` will work only if you cloned the project at least two months ago – if you cloned it five minutes ago, you’ll get no results.
//////////////////////////
Reflog의 일은 모두 로컬의 일이기 때문에 내 Reflog가 동료의 저장소에는 있을 수 없다. 이제 막 Clone 한 저장소는 아무것도 한 것이 없어서 Reflog가 하나도 없다. `git show HEAD@{2.months.ago}` 같은 명령은 적어도 두 달 전에 Clone 한 저장소에서나 사용할 수 있다. 그러니까 이 명령을 5분 전에 Clone 한 저장소에 사용하면 아무 결과도 나오지 않는다.

//////////////////////////
==== Ancestry References
//////////////////////////
==== 계통 관계로 가리키기

//////////////////////////
The other main way to specify a commit is via its ancestry.
If you place a `^` at the end of a reference, Git resolves it to mean the parent of that commit.
Suppose you look at the history of your project:
//////////////////////////
계통 관계로도 커밋을 표현할 수 있다. 이름 끝에 `^`를 붙이면 Git은 해당 커밋의 부모를 찾는다. 프로젝트 히스토리가 아래와 같을 때는 아래처럼 한다.

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

//////////////////////////
Then, you can see the previous commit by specifying `HEAD^`, which means ``the parent of HEAD'':
//////////////////////////
`HEAD^`는 바로 ``HEAD의 부모''를 의미하므로 바로 이전 커밋을 보여준다.

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

//////////////////////////
You can also specify a number after the `^` – for example, `d921970^2` means ``the second parent of d921970.''
This syntax is only useful for merge commits, which have more than one parent.
The first parent is the branch you were on when you merged, and the second is the commit on the branch that you merged in:
//////////////////////////
<<<<<<< HEAD
`^`뒤에 숫자도 사용할 수 있다. 예를 들어 `d921970^2`는 ``d921970의 두 번째 부모''를 의미하기에 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다. 첫 번째 부모는 Merge 할 때 Checkout 했던 브랜치를 말하고 두 번째 부모는 Merge 한 대상 브랜치를 의미한다.
||||||| merged common ancestors
`^`뒤에 숫자도 사용할 수 있다. 예를 들어 `d921970^2`는 ``d921970의 두 번째 부모''를 의미하기에 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다. 첫 번째 부모는 Merge 할 때 Checkout했던 브랜치를 말하고 두 번째 부모는 Merge 한 대상 브랜치를 의미한다.
=======
`^`뒤에 숫자도 사용할 수 있다. 예를 들어 `d921970^2`는 ``d921970의 두 번째 부모''를 의미한다.
그래서 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다.
첫 번째 부모는 Merge 할 때 Checkout했던 브랜치를 말하고 두 번째 부모는 Merge 한 대상 브랜치를 의미한다.
>>>>>>> chapter 7: proofreading

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

//////////////////////////
The other main ancestry specification is the `~`.
This also refers to the first parent, so `HEAD~` and `HEAD^` are equivalent.
The difference becomes apparent when you specify a number.
`HEAD~2` means ``the first parent of the first parent,'' or ``the grandparent'' – it traverses the first parents the number of times you specify.
For example, in the history listed earlier, `HEAD~3` would be
//////////////////////////
계통을 표현하는 방법으로 `~`라는 것도 있다.
`HEAD~`와 `HEAD^`는 똑같이 첫 번째 부모를 가리킨다.
하지만 그 뒤에 숫자를 사용하면 달라진다.
`HEAD~2`는 명령을 실행할 시점의 ``첫 번째 부모의 첫 번째 부모'', 즉 ``조부모''를 가리킨다. 위의 예제에서 `HEAD~3`은 아래와 같다.

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

//////////////////////////
This can also be written `HEAD^^^`, which again is the first parent of the first parent of the first parent:
//////////////////////////
이 것은 `HEAD^^^`와 같은 표현이다. 부모의 부모의 부모 즉 증조부모 쯤 되겠다.

[source,console]
----
$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

//////////////////////////
You can also combine these syntaxes – you can get the second parent of the previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and so on.
//////////////////////////
이 두 표현을 같이 사용할 수도 있다. 위의 예제에서 `HEAD~3^2`를 사용하면 증조부모의 Merge 커밋의 부모의 부모를 조회한다.

[[_commit_ranges]]
//////////////////////////
==== Commit Ranges
//////////////////////////
==== 범위로 커밋 가리키기

//////////////////////////
Now that you can specify individual commits, let’s see how to specify ranges of commits.
This is particularly useful for managing your branches – if you have a lot of branches, you can use range specifications to answer questions such as, ``What work is on this branch that I haven’t yet merged into my main branch?''
//////////////////////////
커밋을 하나씩 조회할 수도 있지만, 범위를 주고 여러 커밋을 한꺼번에 조회할 수도 있다.
범위를 사용하여 조회할 수 있으면 브랜치를 관리할 때 유용하다. 상당히 많은 브랜치를 가지고 있고 ``왜 이 브랜치들은 아직도 주 브랜치에 Merge 도 안 되고 뭐임?''라는 의문이 들면 범위를 주고 어떤 브랜치인지 쉽게 찾을 수 있다.

===== Double Dot

//////////////////////////
The most common range specification is the double-dot syntax.
This basically asks Git to resolve a range of commits that are reachable from one commit but aren’t reachable from another.
For example, say you have a commit history that looks like <<double_dot>>.
//////////////////////////
범위를 표현하는 문법으로 Double Dot(..)을 많이 쓴다.
Double Dot은 어떤 커밋들이 한쪽에는 관련됐고 다른 쪽에는 관련되지 않았는지 Git에게 물어보는 것이다.
예들 들어 <<double_dot>>과 같은 커밋 히스토리가 있다고 가정하자.

[[double_dot]]
//////////////////////////
.Example history for range selection.
image::images/double-dot.png[Example history for range selection.]
//////////////////////////
.범위를 설명하는 데 사용할 예제
image::images/double-dot.png[범위를 설명하는 데 사용할 예제]

//////////////////////////
You want to see what is in your experiment branch that hasn’t yet been merged into your master branch.
You can ask Git to show you a log of just those commits with `master..experiment` – that means ``all commits reachable by experiment that aren’t reachable by master.''
For the sake of brevity and clarity in these examples, I’ll use the letters of the commit objects from the diagram in place of the actual log output in the order that they would display:
//////////////////////////
experiment 브랜치의 커밋들 중에서 아직 master 브랜치에 Merge 하지 않은 것들만 보고 싶으면 `master..experiment`라고 사용한다.
이 표현은 ``master에는 없지만, experiment에는 있는 커밋''을 의미한다.
여기에서는 설명을 쉽게 하려고 실제 조회 결과가 아니라 <<double_dot>>의 문자를 사용한다.

[source,console]
----
$ git log master..experiment
D
C
----

//////////////////////////
If, on the other hand, you want to see the opposite – all commits in `master` that aren’t in `experiment` – you can reverse the branch names.
`experiment..master` shows you everything in `master` not reachable from `experiment`:
//////////////////////////
반대로 `experiment`에는 없고 `master`에만 있는 커밋이 궁금하면 브랜치 순서를 거꾸로 사용한다.
`experiment..master`는 `experiment`에는 없고 `master`에만 있는 것을 알려준다.

[source,console]
----
$ git log experiment..master
F
E
----

//////////////////////////
This is useful if you want to keep the `experiment` branch up to date and preview what you’re about to merge in.
Another very frequent use of this syntax is to see what you’re about to push to a remote:
//////////////////////////
`experiment` 브랜치를 Merge 할 때마다 Merge 하기 전에 무엇이 변경됐는지 확인해보고 싶을 것이다.
그리고 리모트 저장소에 Push 할 때에도 마찬가지로 차이점을 확인해보고 싶을 것이다. 이럴 때 굉장히 유용하다.

[source,console]
----
$ git log origin/master..HEAD
----

//////////////////////////
This command shows you any commits in your current branch that aren’t in the `master` branch on your `origin` remote.
If you run a `git push` and your current branch is tracking `origin/master`, the commits listed by `git log origin/master..HEAD` are the commits that will be transferred to the server.
You can also leave off one side of the syntax to have Git assume HEAD.
For example, you can get the same results as in the previous example by typing `git log origin/master..` – Git substitutes HEAD if one side is missing.
//////////////////////////
<<<<<<< HEAD
이 명령은 `origin` 저장소의 `master` 브랜치에는 없고 현재 Checkout중인 브랜치에만 있는 커밋을 보여준다. Checkout 한 브랜치가 `origin/master`라면 `git log origin/master..HEAD`가 보여주는 커밋이 Push 하면 서버에 전송될 커밋들이다. 그리고 한쪽의 Refs를 생략하면 Git은 HEAD라고 가정하기 때문에 `git log origin/master..`는 `git log origin/master..HEAD`과 같다.
||||||| merged common ancestors
이 명령은 `origin` 저장소의 `master` 브랜치에는 없고 현재 Checkout중인 브랜치에만 있는 커밋을 보여준다. Checkout한 브랜치가 `origin/master`라면 `git log origin/master..HEAD`가 보여주는 커밋이 Push 하면 서버에 전송될 커밋들이다. 그리고 한쪽의 Refs를 생략하면 Git은 HEAD라고 가정하기 때문에 `git log origin/master..`는 `git log origin/master..HEAD`과 같다.
=======
이 명령은 `origin` 저장소의 `master` 브랜치에는 없고 현재 Checkout중인 브랜치에만 있는 커밋을 보여준다.
Checkout한 브랜치가 `origin/master`라면 `git log origin/master..HEAD`가 보여주는 커밋이 Push 하면 서버에 전송될 커밋들이다.
그리고 한쪽의 Refs를 생략하면 Git은 HEAD라고 가정하기 때문에
`git log origin/master..`는 `git log origin/master..HEAD`과 같다.
>>>>>>> chapter 7: proofreading

//////////////////////////
===== Multiple Points
//////////////////////////
===== 세 개 이상의 Refs

//////////////////////////
The double-dot syntax is useful as a shorthand; but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren’t in the branch you’re currently on.
Git allows you to do this by using either the `^` character or `--not` before any reference from which you don’t want to see reachable commits.
Thus these three commands are equivalent:
//////////////////////////
Double Dot은 간단하고 유용하지만 두 개 이상의 브랜치에는 사용할 수 없다. 그러니까 현재 작업 중인 브랜치에는 있지만 다른 여러 브랜치에는 없는 커밋을 보고 싶으면 `..`으로는 확인할 수 없다.
Git은 `^`이나 `--not` 옵션 뒤에 브랜치 이름을 넣으면 그 브랜치에 없는 커밋을 찾아준다.
다음 명령 세 가지는 모두 같은 명령이다.

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

//////////////////////////
This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax.
For instance, if you want to see all commits that are reachable from `refA` or `refB` but not from `refC`, you can type one of these:
//////////////////////////
이 옵션들은 Double Dot으로는 할 수 없는, 세 개 이상의 Refs에 사용할 수 있는 장점이 있다.
예를 들어 `refA`나 `refB`에는 있지만 `refC`에는 없는 커밋을 보려면 다음 중 하나의 명령을 사용한다.

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

//////////////////////////
This makes for a very powerful revision query system that should help you figure out what is in your branches.
//////////////////////////
이 조건을 잘 응용하면 작업 중인 브랜치와 다른 브랜치을 매우 상세하게 비교해볼 수 있다.

[[_triple_dot]]
===== Triple Dot

//////////////////////////
The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them.
Look back at the example commit history in <<double_dot>>.
If you want to see what is in `master` or `experiment` but not any common references, you can run
//////////////////////////
Triple Dot은 양쪽에 있는 두 Refs 사이에서 공통으로 가지는 것을 제외하고 서로 다른 커밋만 보여준다.
<<double_dot>>의 커밋 히스토리를 다시 보자.
만약 `master`와 `experiment`의 공통부분은 빼고 다른 커밋만 보고 싶으면 아래와 같이 하면 된다.

[source,console]
----
$ git log master...experiment
F
E
D
C
----

//////////////////////////
Again, this gives you normal `log` output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.
//////////////////////////
우리가 아는 `log` 명령의 결과를 최근 날짜순으로 보여준다. 이 예제에서는 커밋을 네 개 보여준다.

//////////////////////////
A common switch to use with the `log` command in this case is `--left-right`, which shows you which side of the range each commit is in.
This helps make the data more useful:
//////////////////////////
그리고 `log` 명령에 `--left-right` 옵션을 추가하면 각 커밋이 어느 브랜치에 속하는지도 보여주기 때문에 좀 더 이해하기 쉽다.

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

//////////////////////////
With these tools, you can much more easily let Git know what commit or commits you want to inspect.
//////////////////////////
위와 같은 명령을 사용하면 원하는 커밋을 좀 더 꼼꼼하게 살펴볼 수 있다.
